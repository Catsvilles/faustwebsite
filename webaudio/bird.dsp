declare name "bird";

import("music.lib");
import("oscillator.lib");
import("effect.lib");

/* DESCRIPTION - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

Pierre Cochard - Master 2 RIM 2013-2014
bird-like synthesis for Faust
april 2014

The project aims to mimic bird-like singing patterns via simple synthesis methods and modulations.

This was part of a larger project of environmental soundscape synthesis reproducing birds, wind, rain and thunder. The soundscape was made to be autogenerated by weather forecast online data. The project was originally made on Max/MSP 6.1. There were 3 synthesized birds, with different envelope and synthesis parameters.

This faust project reproduces a simplified version of the synthesis & modulation process, with only one bird and limited envelope expression (no looping and sustain points are implemented here)

1 . The main sound generator ("mainOsc")is composed of a single frequency-modulated sinewave oscillator ("carrierOsc"), with 2 parameters : harmonicity ratio & modulation index, each of them modulated, or "wrapped" by a predefined envelope. The generator responsible for the frequency modulation is an antialiased triangle-wave oscillator ("modOsc"). 

2 . The envelopes are read by the "hitLength" element, which receives a length and a sustain parameter as arguments.
Each time that a "note" is triggered, a randomly generated length value is sent to "hitLength", if the value is different than the previous received one, a phasor is starting, held at the indicated sustain value with a sample & hold process ("gater").

(note that the length value is completely useless here, it was originally supposed to read through random portions of the envelope, but it is not stable and efficient enough yet. the only value that is meaningful is thus the sustain value, which holds the final envelope value).

3 . Each envelope receives a random speed value at each note trigger, meaning that the x.points (and some of the y.points of the frequency envelope too) of the bpf are scaled function of this value (0 to 2 coefficients).

4. The pitch value received by the sound generator is randomly-generated too, contained within two midi values, here : 72 and 94, then converted to frequency values ("mtof")

5. Finally, the sound is "sculpted" by an amplitude envelope, passes through a random stereo panner and a reverb (zita_rev1).

The UI only consists on a Note-trigger button and the zita reverb parameters. To play a sound, just click on the "noteTrig" button.


*/

/*
	Modifications by Grame July 2014
*/


// PROCESS - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

process = hgroup("bird", mainOsc(noteTrig : rdm(72,94) : mtof , noteTrig) * envWrapper(noteTrig, ampEnv, amp_xp(2510)) <: _,_, (rdmPanner : panSte) : panConnect : *,* : reverb);



// AUTO TRIGGER

autoTrig = beat(t) * (abs(noise) <= p) : trigger(48) //tempo(2.5*t))
	with {
		t = vslider("[1]tempo[osc:/1/fader1][style:knob][scale:log]", 120, 1, 480, 0.1);
		p = vslider("[2]probability[osc:/1/fader2][style:knob][scale:log]", 10, 1, 100, 1) / 100.0;
		trigger(n) 	= upfront : release(n) : >(0.0) with {
			upfront(x) 	= (x-x') > 0.0;
			decay(n,x)	= x - (x>0.0)/n;
			release(n)	= + ~ decay(n);
		};
	};


// BIRD TRIGGER

noteTrig = button("[0]play[osc:/2/push1]") + autoTrig : min(1.0);
//noteTrig = autoTrig;


// OSCILLATORS - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  

/* base */
carrierOsc(freq) = osci(freq);
modOsc(freq) = triangleN(3,freq);

/* fm oscillator */
mainOsc(freq,trig) = freq <: +(*(harmRatio <: +(*(envWrapper(trig,harmEnv,harm_xp(1700))))) : modOsc : *(modIndex <: +(*(envWrapper(trig,modIndexEnv,modIndex_xp(550)))))) <: +(*(envWrapper(trig,freqEnv,freq_xp(943)))) : carrierOsc;

envWrapper(trig,env,sus) = trig : mstosamps(rdm(100,3000)), sus : hitLength : env;


// FIXED PARAMETERS - - - - - - - - - - - - - - - - - - - - - - - - - - - 

/* fm */
harmRatio = 0.063;
modIndex = 3.24;


// TIME FUNCTIONS - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

metro(ms) =  (%(+(1),mstosamps(ms))) ~_ : ==(1);
mstosamps(ms) = ms : /(1000) * SR : int;
rdmInc = _ <: @(1), @(2) : + : *(2994.2313) : int : +(38125); 
rdm(rdmin,rdmax) = _,(fmod(_,rdmax - rdmin : int) ~ rdmInc : +(rdmin)) : gater : -(1) : abs;
gater = (_,_,_ <: !,_,!,_,!,!,!,!,_ : select2) ~_;


// MIDI RELATED - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

/* midi pitch */ 
mtof(midinote) = pow(2,(midinote - 69) / 12) * 440;


// ENVELOPPES - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

/* envelope "reader" (phaser) */

hitLength(length,sustain) = *((==(length,@(length,1))), +(1))~_ <: gater(<(sustain));

/* amplitude envelope */

ampEnv = bpf.start(0, 0) : 
	bpf.point(amp_xp(60.241), 1.) : 
	bpf.point(amp_xp(461.847), 0.) :
	bpf.point(amp_xp(582.329), 0.928) : 
	bpf.point(amp_xp(682.731), 0.5) : 
	bpf.point(amp_xp(983.936), 0.) : 
	bpf.point(amp_xp(1064.257), 0.) : 
	bpf.point(amp_xp(1345.382), 0.) : 
	bpf.point(amp_xp(1526.105), 0.) : 
	bpf.point(amp_xp(1746.988), 0.) : 
	bpf.point(amp_xp(1827.309), 0.) : 
	bpf.point(amp_xp(2088.353), 0.) : 
	bpf.point(amp_xp(2188.755), 0.) : /* sustain point */
	bpf.end(amp_xp(2510.040), 0.);

amp_xp(x) = x * SR / 1000. * ampEnv_speed;
ampEnv_speed = noteTrig : rdm(0,2000) : /(1000);

/* freq envelope */

freqEnv =  bpf.start(0, 0) : 
	bpf.point(freq_xp(147.751), 1.) : 
	bpf.point(freq_xp(193.213), 0.) : 
	bpf.point(freq_xp(318.233), yp) : 
	bpf.point(freq_xp(431.888), 0.) : 
	bpf.point(freq_xp(488.715), 0.434) : 
	bpf.point(freq_xp(613.735), yp) : 
	bpf.point(freq_xp(659.197), 1.) : 
	bpf.point(freq_xp(716.024), yp) : 
	bpf.point(freq_xp(806.948), 1.) : 
	bpf.point(freq_xp(829.679), yp) : /* sustain point */
	bpf.end(freq_xp(943.333), 0.);

freq_xp(x) = x * SR / 1000. * freqEnv_speed;
freqEnv_speed = noteTrig : rdm(0,2000) : /(1000);
yp = noteTrig : rdm(0,1000) : /(1000);

/* harmRatio envelope */

harmEnv = bpf.start(0, 0.) : 
	bpf.point(harm_xp(863.454), 0.490) : 
	bpf.point(harm_xp(865), 0.) : 
	bpf.point (harm_xp(1305.221), 1.) : 
	bpf.point(harm_xp(1646.586), 0.) : /* sustain point */
	bpf.end(harm_xp(1700), 0.);

harm_xp(x) = x * SR / 1000. * harmEnv_speed;
harmEnv_speed = noteTrig : rdm(0,2000) : /(1000);

/* modIndex envelope */

modIndexEnv = bpf.start(0, 0.) : 
	bpf.point(modIndex_xp(240.964), 0.554) : 
	bpf.point(modIndex_xp(502.068), 0.) : /* sustain point */
	bpf.end(modIndex_xp(550), 0.);

modIndex_xp(x) = x * SR / 1000. * modIndexEnv_speed;
modIndexEnv_speed = noteTrig : rdm(0,2000) : /(1000);


// PANNER STEREO - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

panSte_UI = hslider("pan-stereo", 0.5, 0., 1., 0.01);
panSte = _ <: -(1,_),_ : sqrt,sqrt;
rdmPanner = noteTrig : rdm(0,1000) : /(1000);

/* cable crosser = 1,3 & 2,4 */
panConnect = _,_,_,_ <: _,!,!,!,!,!,_,!,!,_,!,!,!,!,!,_;


// REVERB BASED OF ZITA - - - - - - - - - - - - - - - - - - - - - - - - - -

reverb(x,y) = zita_rev1_stereo(rdel,f1,f2,t60dc,t60m,fsmax,x,y)
	  : out_eq : dry_wet(x,y) : out_level
with {

  fsmax = 48000.0;  // highest sampling rate that will be used

  rdel = 60;

  f1 = 200;

  t60dc = 3;

  t60m = 2;

  f2 = 6000;

  out_eq = pareq_stereo(eq1f,eq1l,eq1q) : pareq_stereo(eq2f,eq2l,eq2q);

  pareq_stereo(eqf,eql,Q) = peak_eq_rm(eql,eqf,tpbt), peak_eq_rm(eql,eqf,tpbt)
  with {
    tpbt = wcT/sqrt(max(0,g)); // tan(PI*B/SR), B bw in Hz (Q^2 ~ g/4)
    wcT = 2*PI*eqf/SR;  // peak frequency in rad/sample
    g = db2linear(eql); // peak gain
  };


  eq1f = 315;

  eq1l = 0;

  eq1q = 3;

  eq2f = 1500;

  eq2l = 0.0; 

  eq2q = 3.0; 

  //out_group(x)  = x; //fdn_group(hgroup("[5] Output", x));

  dry_wet(x,y) = *(wet) + dry*x, *(wet) + dry*y with {
    wet = 0.5*(drywet+1.0);
    dry = 1.0-wet;
  };

  presence = vslider("[4] proximity[osc:/1/fader3] [style:knob]", 0.5, 0, 1, 0.01) : smooth(0.999);

  drywet = 1 - 2*presence;

  out_level = *(gain),*(gain);

  gain = vslider("[5] level [osc:/1/fader4][unit:dB] [style:knob]", -20, -70, 40, 0.1)
    : +(6*presence) : db2linear : smooth(0.999);

};
