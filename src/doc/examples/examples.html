<div class="container-fluid"><div class="row faust-doc"><nav id="TOC" class="col-3 faust-doc-content"><div style="height: 100%;overflow-y: scroll;"><ul class="nav nav-pills flex-column"><ul>
<li><a class="nav-link" href="#faust-examples">Faust Examples</a></li>
<li><a class="nav-link" href="#ambisonics">ambisonics</a><ul>
<li><a class="nav-link" href="#foursourcestoocto">fourSourcesToOcto</a></li>
<li><a class="nav-link" href="#onesourcetostereo">oneSourceToStereo</a></li>
</ul></li>
<li><a class="nav-link" href="#analysis">analysis</a><ul>
<li><a class="nav-link" href="#dbmeter">dbmeter</a></li>
<li><a class="nav-link" href="#fft">FFT</a></li>
<li><a class="nav-link" href="#spectrallevel">spectralLevel</a></li>
<li><a class="nav-link" href="#spectraltiltlab">spectralTiltLab</a></li>
<li><a class="nav-link" href="#vumeter">vumeter</a></li>
</ul></li>
<li><a class="nav-link" href="#bela">bela</a><ul>
<li><a class="nav-link" href="#additivesynth_analog">AdditiveSynth_Analog</a></li>
<li><a class="nav-link" href="#additivesynth">AdditiveSynth</a></li>
<li><a class="nav-link" href="#crossdelay2">crossDelay2</a></li>
<li><a class="nav-link" href="#fmsynth2_analog">FMSynth2_Analog</a></li>
<li><a class="nav-link" href="#fmsynth2">FMSynth2</a></li>
<li><a class="nav-link" href="#fmsynth2_fx_analog">FMSynth2_FX_Analog</a></li>
<li><a class="nav-link" href="#fmsynth2_fx">FMSynth2_FX</a></li>
<li><a class="nav-link" href="#fxchaine2">FXChaine2</a></li>
<li><a class="nav-link" href="#graingenerator">GrainGenerator</a></li>
<li><a class="nav-link" href="#granulator">granulator</a></li>
<li><a class="nav-link" href="#repeater">repeater</a></li>
<li><a class="nav-link" href="#simplefx_analog">simpleFX_Analog</a></li>
<li><a class="nav-link" href="#simplefx">simpleFX</a></li>
<li><a class="nav-link" href="#simplesynth_analog">simpleSynth_Analog</a></li>
<li><a class="nav-link" href="#simplesynth">simpleSynth</a></li>
<li><a class="nav-link" href="#simplesynth_fx_analog">simpleSynth_FX_Analog</a></li>
<li><a class="nav-link" href="#simplesynth_fx">simpleSynth_FX</a></li>
<li><a class="nav-link" href="#wavesynth_analog">WaveSynth_Analog</a></li>
<li><a class="nav-link" href="#wavesynth">WaveSynth</a></li>
<li><a class="nav-link" href="#wavesynth_fx_analog">WaveSynth_FX_Analog</a></li>
<li><a class="nav-link" href="#wavesynth_fx">WaveSynth_FX</a></li>
</ul></li>
<li><a class="nav-link" href="#delayecho">delayEcho</a><ul>
<li><a class="nav-link" href="#echo">echo</a></li>
<li><a class="nav-link" href="#quadecho">quadEcho</a></li>
<li><a class="nav-link" href="#smoothdelay">smoothDelay</a></li>
<li><a class="nav-link" href="#stereoecho">stereoEcho</a></li>
<li><a class="nav-link" href="#tapiir">tapiir</a></li>
</ul></li>
<li><a class="nav-link" href="#dynamic">dynamic</a><ul>
<li><a class="nav-link" href="#compressor">compressor</a></li>
<li><a class="nav-link" href="#distortion">distortion</a></li>
<li><a class="nav-link" href="#gatecompressor">gateCompressor</a></li>
<li><a class="nav-link" href="#noisegate">noiseGate</a></li>
<li><a class="nav-link" href="#volume">volume</a></li>
</ul></li>
<li><a class="nav-link" href="#filtering">filtering</a><ul>
<li><a class="nav-link" href="#apf">APF</a></li>
<li><a class="nav-link" href="#bandfilter">bandFilter</a></li>
<li><a class="nav-link" href="#bpf">BPF</a></li>
<li><a class="nav-link" href="#crybaby">cryBaby</a></li>
<li><a class="nav-link" href="#dnn">DNN</a></li>
<li><a class="nav-link" href="#filterbank">filterBank</a></li>
<li><a class="nav-link" href="#graphiceqlab">graphicEqLab</a></li>
<li><a class="nav-link" href="#highshelf">highShelf</a></li>
<li><a class="nav-link" href="#hpf">HPF</a></li>
<li><a class="nav-link" href="#lfboost">lfBoost</a></li>
<li><a class="nav-link" href="#lowboost">lowBoost</a></li>
<li><a class="nav-link" href="#lowcut">lowCut</a></li>
<li><a class="nav-link" href="#lowshelf">lowShelf</a></li>
<li><a class="nav-link" href="#lpf">LPF</a></li>
<li><a class="nav-link" href="#moogvcf">moogVCF</a></li>
<li><a class="nav-link" href="#notch">notch</a></li>
<li><a class="nav-link" href="#parametriceqlab">parametricEqLab</a></li>
<li><a class="nav-link" href="#parametricequalizer">parametricEqualizer</a></li>
<li><a class="nav-link" href="#peakingeq">peakingEQ</a></li>
<li><a class="nav-link" href="#peaknotch">peakNotch</a></li>
<li><a class="nav-link" href="#spectraltilt">spectralTilt</a></li>
<li><a class="nav-link" href="#vcfwahlab">vcfWahLab</a></li>
<li><a class="nav-link" href="#vocoder">vocoder</a></li>
<li><a class="nav-link" href="#wahpedal">wahPedal</a></li>
</ul></li>
<li><a class="nav-link" href="#gameaudio">gameaudio</a><ul>
<li><a class="nav-link" href="#bubble">bubble</a></li>
<li><a class="nav-link" href="#rain">rain</a></li>
<li><a class="nav-link" href="#wind">wind</a></li>
</ul></li>
<li><a class="nav-link" href="#generator">generator</a><ul>
<li><a class="nav-link" href="#filterosc">filterOsc</a></li>
<li><a class="nav-link" href="#noise">noise</a></li>
<li><a class="nav-link" href="#noisemetadata">noiseMetadata</a></li>
<li><a class="nav-link" href="#osc">osc</a></li>
<li><a class="nav-link" href="#osci">osci</a></li>
<li><a class="nav-link" href="#sawtoothlab">sawtoothLab</a></li>
<li><a class="nav-link" href="#virtualanalog">virtualAnalog</a></li>
<li><a class="nav-link" href="#virtualanaloglab">virtualAnalogLab</a></li>
</ul></li>
<li><a class="nav-link" href="#misc">misc</a><ul>
<li><a class="nav-link" href="#capture">capture</a></li>
<li><a class="nav-link" href="#matrix">matrix</a></li>
<li><a class="nav-link" href="#miditester">midiTester</a></li>
<li><a class="nav-link" href="#switcher">switcher</a></li>
<li><a class="nav-link" href="#tester2">tester2</a></li>
<li><a class="nav-link" href="#tester">tester</a></li>
<li><a class="nav-link" href="#uitester">UITester</a></li>
</ul></li>
<li><a class="nav-link" href="#old">old</a><ul>
<li><a class="nav-link" href="#freeverb">freeverb</a></li>
</ul></li>
<li><a class="nav-link" href="#phasing">phasing</a><ul>
<li><a class="nav-link" href="#flanger">flanger</a></li>
<li><a class="nav-link" href="#phaser">phaser</a></li>
<li><a class="nav-link" href="#phaserflangerlab">phaserFlangerLab</a></li>
</ul></li>
<li><a class="nav-link" href="#physicalmodeling">physicalModeling</a><ul>
<li><a class="nav-link" href="#brass">brass</a></li>
<li><a class="nav-link" href="#brassmidi">brassMIDI</a></li>
<li><a class="nav-link" href="#churchbell">churchBell</a></li>
<li><a class="nav-link" href="#clarinet">clarinet</a></li>
<li><a class="nav-link" href="#clarinetmidi">clarinetMIDI</a></li>
<li><a class="nav-link" href="#djembemidi">djembeMIDI</a></li>
<li><a class="nav-link" href="#elecguitarmidi">elecGuitarMIDI</a></li>
<li><a class="nav-link" href="#englishbell">englishBell</a></li>
<li><a class="nav-link" href="#flute">flute</a></li>
<li><a class="nav-link" href="#flutemidi">fluteMIDI</a></li>
<li><a class="nav-link" href="#frenchbell">frenchBell</a></li>
<li><a class="nav-link" href="#germanbell">germanBell</a></li>
<li><a class="nav-link" href="#guitarmidi">guitarMIDI</a></li>
<li><a class="nav-link" href="#karplus">karplus</a></li>
<li><a class="nav-link" href="#marimbamidi">marimbaMIDI</a></li>
<li><a class="nav-link" href="#modularinterpinstrmidi">modularInterpInstrMIDI</a></li>
<li><a class="nav-link" href="#nylonguitarmidi">nylonGuitarMIDI</a></li>
<li><a class="nav-link" href="#russianbell">russianBell</a></li>
<li><a class="nav-link" href="#standardbell">standardBell</a></li>
<li><a class="nav-link" href="#violin">violin</a></li>
<li><a class="nav-link" href="#violinmidi">violinMIDI</a></li>
<li><a class="nav-link" href="#vocalbp">vocalBP</a></li>
<li><a class="nav-link" href="#vocalbpmidi">vocalBPMIDI</a></li>
<li><a class="nav-link" href="#vocalfof">vocalFOF</a></li>
<li><a class="nav-link" href="#vocalfofmidi">vocalFOFMIDI</a></li>
</ul></li>
<li><a class="nav-link" href="#pitchshifting">pitchShifting</a><ul>
<li><a class="nav-link" href="#pitchshifter">pitchShifter</a></li>
</ul></li>
<li><a class="nav-link" href="#psychoacoustic">psychoacoustic</a><ul>
<li><a class="nav-link" href="#harmonicexciter">harmonicExciter</a></li>
</ul></li>
<li><a class="nav-link" href="#reverb">reverb</a><ul>
<li><a class="nav-link" href="#fdnrev">fdnRev</a></li>
<li><a class="nav-link" href="#freeverb-1">freeverb</a></li>
<li><a class="nav-link" href="#reverbdesigner">reverbDesigner</a></li>
<li><a class="nav-link" href="#reverbtester">reverbTester</a></li>
<li><a class="nav-link" href="#zitarev">zitaRev</a></li>
<li><a class="nav-link" href="#zitarevfdn">zitaRevFDN</a></li>
</ul></li>
<li><a class="nav-link" href="#sam">SAM</a></li>
<li><a class="nav-link" href="#smartkeyboard">smartKeyboard</a><ul>
<li><a class="nav-link" href="#acguitar">acGuitar</a></li>
<li><a class="nav-link" href="#bells">bells</a></li>
<li><a class="nav-link" href="#bowed">bowed</a></li>
<li><a class="nav-link" href="#brass-1">brass</a></li>
<li><a class="nav-link" href="#clarinet-1">clarinet</a></li>
<li><a class="nav-link" href="#crazyguiro">crazyGuiro</a></li>
<li><a class="nav-link" href="#drums">drums</a></li>
<li><a class="nav-link" href="#dubdub">dubDub</a></li>
<li><a class="nav-link" href="#elecguitar">elecGuitar</a></li>
<li><a class="nav-link" href="#fm">fm</a></li>
<li><a class="nav-link" href="#frog">frog</a></li>
<li><a class="nav-link" href="#harp">harp</a></li>
<li><a class="nav-link" href="#midionly">midiOnly</a></li>
<li><a class="nav-link" href="#multisynth">multiSynth</a></li>
<li><a class="nav-link" href="#toy">toy</a></li>
<li><a class="nav-link" href="#trumpet">trumpet</a></li>
<li><a class="nav-link" href="#turenas">turenas</a></li>
<li><a class="nav-link" href="#violin2">violin2</a></li>
<li><a class="nav-link" href="#violin-1">violin</a></li>
<li><a class="nav-link" href="#vocal">vocal</a></li>
</ul></li>
<li><a class="nav-link" href="#spat">spat</a><ul>
<li><a class="nav-link" href="#panpot">panpot</a></li>
<li><a class="nav-link" href="#spat-1">spat</a></li>
</ul></li>
</ul>
</div>
</nav>
<main role="main" class="col-9 ml-sm-auto px-4 faust-doc-content">
<div data-spy="scroll" data-target="#TOC" data-offset="100" style="height: 100%;overflow-y: scroll;">
<!-- doc-begin -->
<h1 id="faust-examples">Faust Examples</h1>
<p>This page contains an overview of the <a href="https://github.com/grame-cncm/faust/tree/master-dev/architecture"><code>examples</code> folder of the Faust distribution</a>. Examples are organized by category and should all be executable in the online editor by clicking on the “Try it Yourself” button.</p>
<h1 id="ambisonics">ambisonics</h1>
<h2 id="foursourcestoocto">fourSourcesToOcto</h2>
<div class="faust-run"><a href="img/src/exfaust0/exfaust0-svg/process.svg" target="_blank"><img src="img/src/exfaust0/exfaust0-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;fourSourcesToOcto&quot;;
declare version &quot;1.0&quot;;
declare author &quot;CICM&quot;;
declare license &quot;BSD&quot;;
declare copyright &quot;(c)CICM 2013&quot;;

import(&quot;stdfaust.lib&quot;);

r1 = hslider(&quot;Radius1&quot;, 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02));
a1 = hslider(&quot;Angle1&quot;, 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02));
r2 = hslider(&quot;Radius2&quot;, 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02));
a2 = hslider(&quot;Angle2&quot;, 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02));
r3 = hslider(&quot;Radius3&quot;, 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02));
a3 = hslider(&quot;Angle3&quot;, 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02));
r4 = hslider(&quot;Radius4&quot;, 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02));
a4 = hslider(&quot;Angle4&quot;, 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02));

process(sig1, sig2, sig3, sig4) = ho.map(3, sig1, r1, a1), ho.map(3, sig2, r2, a2), ho.map(3, sig3, r3, a3), ho.map(3, sig4, r4, a4) :&gt; ho.optimInPhase(3) : ho.decoder(3, 8);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust0/exfaust0.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="onesourcetostereo">oneSourceToStereo</h2>
<div class="faust-run"><a href="img/src/exfaust1/exfaust1-svg/process.svg" target="_blank"><img src="img/src/exfaust1/exfaust1-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;oneSourceToStereo&quot;;
declare version &quot;1.0&quot;;
declare author &quot;CICM&quot;;
declare license &quot;BSD&quot;;
declare copyright &quot;(c)CICM 2013&quot;;

import(&quot;stdfaust.lib&quot;);

r1 = hslider(&quot;Radius&quot;, 1.0, 0, 5, 0.001) : si.smooth(ba.tau2pole(0.02));
a1 = hslider(&quot;Angle&quot;, 0, ma.PI*(-2), ma.PI*2, 0.001) : si.smooth(ba.tau2pole(0.02));

process(sig) = ho.map(7, sig, r1, a1) : ho.optimInPhase(7) : ho.decoderStereo(7);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust1/exfaust1.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="analysis">analysis</h1>
<h2 id="dbmeter">dbmeter</h2>
<div class="faust-run"><a href="img/src/exfaust2/exfaust2-svg/process.svg" target="_blank"><img src="img/src/exfaust2/exfaust2-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;dbmeter&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-------------------------------------------------
// A dB Vumeter
//-------------------------------------------------

import(&quot;stdfaust.lib&quot;);


vmeter(x)       = attach(x, envelop(x) : vbargraph(&quot;[unit:dB]&quot;, -70, 10));
hmeter(x)       = attach(x, envelop(x) : hbargraph(&quot;[unit:dB]&quot;, -70, 10));

envelop         = abs : max(ba.db2linear(-70)) : ba.linear2db : min(10)  : max ~ -(80.0/ma.SR);
null(x)         = attach(0,x);
process         = hgroup(&quot;8 channels dB meter&quot;, par(i,8, vgroup(&quot;%i&quot;, vmeter : null)));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust2/exfaust2.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fft">FFT</h2>
<div class="faust-run"><a href="img/src/exfaust3/exfaust3-svg/process.svg" target="_blank"><img src="img/src/exfaust3/exfaust3-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// Radix 2 FFT, decimation in time, real and imag parts interleaved

declare name    &quot;FFT&quot;; // Faust Fourier Transform :-)
declare author  &quot;JOS&quot;;
declare license &quot;STK-4.3&quot;;

import(&quot;stdfaust.lib&quot;);

N=32; // FFT size (power of 2)
// Number of frequency bins (including dc and SR/2) is N/2+1

No2 = N&gt;&gt;1;
signal = amp * cosine with {
  cosine = select2(k==0,
         select2(k==No2,
            2.0*os.oscrc(f(k)), // 2x since negative-frequencies not displayed
            1-1&#39;:+~*(-1) // Alternating sequence: 1, -1, 1, -1
            ),
           1.0); // make sure phase is zero (freq jumps around)
  f(k) = float(k) * ma.SR / float(N); // only test FFT bin frequencies
  k = hslider(&quot;[2] FFT Bin Number&quot;,N/4,0,No2,0.001) : int &lt;: _,dpy : attach;
  dpy = hbargraph(&quot;[3] Measured FFT Bin Number&quot;,0,No2);
  amp = hslider(&quot;[4] Amplitude&quot;,0.1,0,1,0.001);
};

process = signal : dm.fft_spectral_level_demo(N) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust3/exfaust3.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="spectrallevel">spectralLevel</h2>
<div class="faust-run"><a href="img/src/exfaust4/exfaust4-svg/process.svg" target="_blank"><img src="img/src/exfaust4/exfaust4-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;spectralLevel&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Demonstrates mth_octave_spectral_level in a standalone GUI.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.spectral_level_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust4/exfaust4.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="spectraltiltlab">spectralTiltLab</h2>
<div class="faust-run"><a href="img/src/exfaust5/exfaust5-svg/process.svg" target="_blank"><img src="img/src/exfaust5/exfaust5-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// example exercising filters.lib&#39;s spectral_tilt_demo

declare name &quot;spectralTiltLab&quot;;

import(&quot;stdfaust.lib&quot;);

N = 10; // Number of pole-zero pairs to use

process = sig(dm.sawtooth_demo) 
     : stg(ba.bypass1(bp,dm.spectral_tilt_demo(N)))
    &lt;: sag(dm.spectral_level_demo) 
with {
    bp = stg(checkbox(&quot;[0] Bypass Spectral Tilt&quot;));
    stg(x) = vgroup(
     &quot;[1] Spectral Tilt Filter [tooltip: See Faust&#39;s filters.lib for spectral_tilt_demo]&quot;,x);
    sig(x) = vgroup(
     &quot;[2] Test Signal [tooltip: See Faust&#39;s oscillator.lib for sawtooth_demo]&quot;,x);
    sag(x) = vgroup(
     &quot;[4] Spectrum Analyzer [tooltip: See Faust&#39;s filters.lib for spectral_level_demo]&quot;,x);
};</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust5/exfaust5.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vumeter">vumeter</h2>
<div class="faust-run"><a href="img/src/exfaust6/exfaust6-svg/process.svg" target="_blank"><img src="img/src/exfaust6/exfaust6-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;vumeter&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-------------------------------------------------
// Simple vumeter
//-------------------------------------------------

import(&quot;stdfaust.lib&quot;);


vmeter(x)       = attach(x, envelop(x) : vbargraph(&quot;[2][unit:dB]&quot;, -70, +5));
hmeter(x)       = attach(x, envelop(x) : hbargraph(&quot;[2][unit:dB]&quot;, -70, +5));

envelop         = abs : max ~ -(1.0/ma.SR) : max(ba.db2linear(-70)) : ba.linear2db;

process         = hmeter,hmeter;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust6/exfaust6.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="bela">bela</h1>
<h2 id="additivesynth_analog">AdditiveSynth_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust7/exfaust7-svg/process.svg" target="_blank"><img src="img/src/exfaust7/exfaust7-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Additive synthesizer, must be used with OSC message to program sound.
// It as 8 harmonics. Each have it&#39;s own volume envelope.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : vol0 (volum of fundamental)
// ANALOG_1 : vol1
// ...
// ANALOG_7 : vol7
//
// OSC messages (see BELA console for precise adress)
// For each harmonics (%rang indicate harmonic number, starting at 0) :
// A%rang : Attack
// D%rang : Decay
// S%rang : Sustain
// R%rang : Release
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// GENERAL
midigate = button(&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 10, 0.01);

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

partiel(rang) = os.oscrs(gFreq*(rang+1))*volume
    with {
        // UI
        vol = hslider(&quot;vol%rang[BELA: ANALOG_%rang]&quot;, 1, 0, 1, 0.001);
     
        a = 0.01 * hslider(&quot;A%rang&quot;, 1, 0, 400, 0.001);
        d = 0.01 * hslider(&quot;D%rang&quot;, 1, 0, 400, 0.001);
        s = hslider(&quot;S%rang&quot;, 1, 0, 1, 0.001);
        r = 0.01 * hslider(&quot;R%rang&quot;, 1, 0, 800, 0.001);

        volume = ((en.adsr(a,d,s,r,midigate))*vol) : max (0) : min (1);
    };

process = par(i, 8, partiel(i)) :&gt; / (8);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust7/exfaust7.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="additivesynth">AdditiveSynth</h2>
<div class="faust-run"><a href="img/src/exfaust8/exfaust8-svg/process.svg" target="_blank"><img src="img/src/exfaust8/exfaust8-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Additive synthesizer, must be used with OSC message to program sound.
// It as 8 harmonics. Each have it&#39;s own volume envelope.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// OSC messages (see BELA console for precise adress)
// For each harmonics (%rang indicate harmonic number, starting at 0) :
// vol%rang : General Volume        (vol0 control the volume of the fundamental)
// A%rang : Attack
// D%rang : Decay
// S%rang : Sustain
// R%rang : Release
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// GENERAL
midigate = button(&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 10, 0.01);

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

partiel(rang) = os.oscrs(gFreq*(rang+1))*volume
    with {
        // UI
        vol = hslider(&quot;vol%rang&quot;, 1, 0, 1, 0.001);
     
        a = 0.01 * hslider(&quot;A%rang&quot;, 1, 0, 400, 0.001);
        d = 0.01 * hslider(&quot;D%rang&quot;, 1, 0, 400, 0.001);
        s = hslider(&quot;S%rang&quot;, 1, 0, 1, 0.001);
        r = 0.01 * hslider(&quot;R%rang&quot;, 1, 0, 800, 0.001);

        volume = ((en.adsr(a,d,s,r,midigate))*vol) : max (0) : min (1);
    };

process = par(i, 8, partiel(i)) :&gt; / (8);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust8/exfaust8.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="crossdelay2">crossDelay2</h2>
<div class="faust-run"><a href="img/src/exfaust9/exfaust9-svg/process.svg" target="_blank"><img src="img/src/exfaust9/exfaust9-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Stereo Delay with feedback and crossfeedback (L to R and R to L feedback).
// And pitch shifting on feedback.
// A pre-delay without feedback is added for a wider stereo effect.
//
// Designed to use the Analog Input for parameters controls.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// ANALOG IN:
// ANALOG 0 : Pre-Delay L
// ANALOG 1 : Pre-Delay R
// ANALOG 2 : Delay L
// ANALOG 3 : Delay R
// ANALOG 4 : Cross feedback
// ANALOG 5 : Feedback
// ANALOG 6 : Pitchshifter L
// ANALOG 7 : Pitchshifter R
//
// Available by OSC :  (see BELA console for precise adress)
// Feedback filter:
// crossLF : Crossfeedback Lowpass
// crossHF : Crossfeedback Highpass
// feedbLF : Feedback Lowpass
// feedbHF : Feedback Highpass
//
///////////////////////////////////////////////////////////////////////////////////////////////////

preDelL = ba.sec2samp(hslider(&quot;delR[BELA: ANALOG_0]&quot;, 1,0,2,0.001)):si.smoo;
preDelR = ba.sec2samp(hslider(&quot;delR[BELA: ANALOG_1]&quot;, 1,0,2,0.001)):si.smoo;
delL    = ba.sec2samp(hslider(&quot;delL[BELA: ANALOG_2]&quot;, 1,0,2,0.001)):si.smoo;
delR    = ba.sec2samp(hslider(&quot;delR[BELA: ANALOG_3]&quot;, 1,0,2,0.001)):si.smoo;

crossLF = hslider(&quot;crossLF&quot;, 12000, 20, 20000, 0.001);
crossHF = hslider(&quot;crossLF&quot;, 60, 20, 20000, 0.001);
feedbLF = hslider(&quot;feedbLF&quot;, 12000, 20, 20000, 0.001);
feedbHF = hslider(&quot;feedbHF&quot;, 60, 20, 20000, 0.001);

CrossFeedb = hslider(&quot;CrossFeedb[BELA: ANALOG_4]&quot;, 0.0, 0., 1, 0.001):si.smoo;
feedback = hslider(&quot;feedback[BELA: ANALOG_5]&quot;, 0.0, 0., 1, 0.001):si.smoo;

pitchL = hslider(&quot;shiftL[BELA: ANALOG_6]&quot;, 0,-12,12,0.001):si.smoo;
pitchR = hslider(&quot;shiftL[BELA: ANALOG_7]&quot;, 0,-12,12,0.001):si.smoo;

routeur(a,b,c,d) = ((a*CrossFeedb):fi.lowpass(2,crossLF):fi.highpass(2,crossHF))+((b*feedback):fi.lowpass(2,feedbLF):fi.highpass(2,feedbHF))+c,
                    ((b*CrossFeedb):fi.lowpass(2,crossLF):fi.highpass(2,crossHF))+((a*feedback):fi.lowpass(2,feedbLF):fi.highpass(2,feedbHF))+d;

process = (de.sdelay(65536, 512,preDelL),de.sdelay(65536, 512,preDelR)):(routeur : de.sdelay(65536, 512,delL) , de.sdelay(65536, 512,delR))~(ef.transpose(512, 256, pitchL) , ef.transpose(512, 256, pitchR));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust9/exfaust9.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fmsynth2_analog">FMSynth2_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust10/exfaust10-svg/process.svg" target="_blank"><img src="img/src/exfaust10/exfaust10-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;all.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple FM synthesizer.

///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : Modulator frequency ratio
// ANALOG_1 : Attack
// ANALOG_2 : Decay/Release
// ANALOG_3 : Sustain
//
// MIDI:
// CC 1 : FM feedback on modulant oscillator.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// GENERAL, Keyboard
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 1, 0, 1, 0.01);

// modwheel:
feedb = (gFreq-1) * (hslider(&quot;feedb[midi:ctrl 1]&quot;, 0, 0, 1, 0.001) : si.smoo);
modFreqRatio = hslider(&quot;ratio[BELA: ANALOG_0]&quot;,2,0,20,0.01) : si.smoo;

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

//=================================== Parameters Mapping =================================
//========================================================================================
// Same for volum &amp; modulation:
volA = hslider(&quot;A[BELA: ANALOG_1]&quot;,0.01,0.01,4,0.01);
volDR = hslider(&quot;DR[BELA: ANALOG_2]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[BELA: ANALOG_3]&quot;,0.2,0,1,0.01);
envelop = en.adsre(volA,volDR,volS,volDR,midigate);

// modulator frequency
modFreq = gFreq * modFreqRatio;

// modulation index
FMdepth = envelop * 1000 * midigain;

// Out Amplitude
vol = envelop;

//============================================ DSP =======================================
//========================================================================================

FMfeedback(frq) = (+(_,frq):os.osci) ~ (* (feedb));
FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio)));

process = FMall(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust10/exfaust10.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fmsynth2">FMSynth2</h2>
<div class="faust-run"><a href="img/src/exfaust11/exfaust11-svg/process.svg" target="_blank"><img src="img/src/exfaust11/exfaust11-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;all.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple FM synthesizer.
// 2 oscillators and FM feedback on modulant oscillator
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
//
// CC 1 : FM feedback on modulant oscillator.
// CC 14 : Modulator frequency ratio.
//
// CC 73 : Attack
// CC 76 : Decay
// CC 77 : Sustain
// CC 72 : Release
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// GENERAL, Keyboard
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 1, 0, 1, 0.01);

// modwheel:
feedb = (gFreq-1) * (hslider(&quot;feedb[midi:ctrl 1]&quot;, 0, 0, 1, 0.001) : si.smoo);
modFreqRatio = hslider(&quot;ratio[midi:ctrl 14]&quot;,2,0,20,0.01) : si.smoo;

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

//=================================== Parameters Mapping =================================
//========================================================================================
// Same for volum &amp; modulation:
volA = hslider(&quot;A[midi:ctrl 73]&quot;,0.01,0.01,4,0.01);
volD = hslider(&quot;D[midi:ctrl 76]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[midi:ctrl 77]&quot;,0.2,0,1,0.01);
volR = hslider(&quot;R[midi:ctrl 72]&quot;,0.8,0.01,8,0.01);
envelop = en.adsre(volA,volD,volS,volR,midigate);

// modulator frequency
modFreq = gFreq*modFreqRatio;

// modulation index
FMdepth = envelop * 1000 * midigain;

// Out Amplitude
vol = envelop;

//============================================ DSP =======================================
//========================================================================================

FMfeedback(frq) = (+(_,frq):os.osci ) ~ (* (feedb));
FMall(f) = os.osci(f+(FMdepth*FMfeedback(f*modFreqRatio)));

process = FMall(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust11/exfaust11.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fmsynth2_fx_analog">FMSynth2_FX_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust12/exfaust12-svg/process.svg" target="_blank"><img src="img/src/exfaust12/exfaust12-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;all.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple FM synthesizer.
// 2 oscillators and FM feedback on modulant oscillator
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : Modulator frequency ratio
// ANALOG_1 : Attack
// ANALOG_2 : Decay/Release
// ANALOG_3 : Sustain
//
// MIDI:
// CC 1 : FM feedback on modulant oscillator.
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// GENERAL, Keyboard
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 1, 0, 1, 0.01);

// modwheel:
feedb = (gFreq-1) * (hslider(&quot;feedb[midi:ctrl 1]&quot;, 0, 0, 1, 0.001) : si.smoo);
modFreqRatio = hslider(&quot;ratio[BELA: ANALOG_0]&quot;,2,0,20,0.01) : si.smoo;

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

//=================================== Parameters Mapping =================================
//========================================================================================
// Same for volum &amp; modulation:
volA = hslider(&quot;A[BELA: ANALOG_1]&quot;,0.01,0.01,4,0.01);
volDR = hslider(&quot;DR[BELA: ANALOG_2]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[BELA: ANALOG_3]&quot;,0.2,0,1,0.01);
envelop = en.adsre(volA,volDR,volS,volDR,midigate);

// modulator frequency
modFreq = gFreq * modFreqRatio;

// modulation index
FMdepth = envelop * 1000 * midigain;

// Out Amplitude
vol = envelop;

//============================================ DSP =======================================
//========================================================================================

FMfeedback(frq) = (+(_,frq):os.osci) ~ (* (feedb));
FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio)));

//#################################################################################################//
//##################################### EFFECT SECTION ############################################//
//#################################################################################################//
//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
// This version use ANALOG IN to controle some of the parameters.
// Other parameters continue to be available by MIDI or OSC.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_4 : Distortion Drive
// ANALOG_5 : Flanger Dry/Wet
// ANALOG_6 : Reverberation Dry/Wet
// ANALOG_7 : Reverberation Room size
//
// MIDI:
// CC 7 : Volume
// CC 10 : Pan
//
// CC 13 : Flanger Delay
// CC 13 : Flanger Delay
// CC 94 : Flanger Feedback
//
// CC 95 : Reverberation Damp
// CC 90 : Reverberation Stereo Width
// 
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
volFX   = hslider(&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);   // Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive   = hslider(&quot;drive[BELA: ANALOG_4]&quot;,0.3,0,1,0.001);

// Flanger
curdel  = hslider(&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb      = hslider(&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw    = hslider(&quot;dryWetFlang[BELA: ANALOG_5]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[BELA: ANALOG_7]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[BELA: ANALOG_6]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

process = FMall(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust12/exfaust12.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fmsynth2_fx">FMSynth2_FX</h2>
<div class="faust-run"><a href="img/src/exfaust13/exfaust13-svg/process.svg" target="_blank"><img src="img/src/exfaust13/exfaust13-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;all.lib&quot;);


///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple FM synthesizer.
// 2 oscillators and FM feedback on modulant oscillator
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
//
// CC 1     : FM feedback on modulant oscillator.
// CC 14    : Modulator frequency ratio.
//
// CC 73    : Attack
// CC 76    : Decay
// CC 77    : Sustain
// CC 72    : Release
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// GENERAL, Keyboard
midigate        = button (&quot;gate&quot;);
midifreq        = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain        = nentry(&quot;gain&quot;, 1, 0, 1, 0.01);

// modwheel:
feedb = (gFreq-1) * (hslider(&quot;feedb[midi:ctrl 1]&quot;, 0, 0, 1, 0.001) : si.smoo);
modFreqRatio = hslider(&quot;ratio[midi:ctrl 14]&quot;,2,0,20,0.01) : si.smoo;

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

//=================================== Parameters Mapping =================================
//========================================================================================
// Same for volum &amp; modulation:
volA = hslider(&quot;A[midi:ctrl 73]&quot;,0.01,0.01,4,0.01);
volD = hslider(&quot;D[midi:ctrl 76]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[midi:ctrl 77]&quot;,0.2,0,1,0.01);
volR = hslider(&quot;R[midi:ctrl 72]&quot;,0.8,0.01,8,0.01);
envelop = en.adsre(volA,volD,volS,volR,midigate);

// modulator frequency
modFreq = gFreq*modFreqRatio;

// modulation index
FMdepth = envelop * 1000 * midigain;

// Out Amplitude
vol = envelop;

//============================================ DSP =======================================
//========================================================================================

FMfeedback(frq) = ( +(_,frq):os.osci ) ~ (* (feedb));
FMall(f) = os.osci(f+ (FMdepth*FMfeedback(f*modFreqRatio)));

//#################################################################################################//
//##################################### EFFECT SECTION ############################################//
//#################################################################################################//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
// (All are available by OSC)
//
// CC 7 : Volume
// CC 10 : Pan
//
// CC 92 : Distortion Drive
//
// CC 13 : Flanger Delay
// CC 93 : Flanger Dry/Wet
// CC 94 : Flanger Feedback
//
// CC 12 : Reverberation Room size
// CC 91 : Reverberation Dry/Wet
// CC 95 : Reverberation Damp
// CC 90 : Reverberation Stereo Width
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
volFX = hslider(&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive = hslider(&quot;drive[midi:ctrl 92]&quot;,0.3,0,1,0.001);

// Flanger
curdel  = hslider(&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb = hslider(&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw = hslider(&quot;dryWetFlang[midi:ctrl 93]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[midi:ctrl 12]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[midi:ctrl 91]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

process = FMall(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust13/exfaust13.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fxchaine2">FXChaine2</h2>
<div class="faust-run"><a href="img/src/exfaust14/exfaust14-svg/process.svg" target="_blank"><img src="img/src/exfaust14/exfaust14-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// A complete Stereo FX chain with:
//      CHORUS
//      PHASER
//      DELAY
//      REVERB
//
// Designed to use the Analog Input for parameters controls.
//
// CONTROLES ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// ANALOG IN:
// ANALOG 0 : Chorus Depth
// ANALOG 1 : Chorus Delay
// ANALOG 2 : Phaser Dry/Wet
// ANALOG 3 : Phaser Frequency ratio
// ANALOG 4 : Delay Dry/Wet
// ANALOG 5 : Delay Time
// ANALOG 6 : Reverberation Dry/Wet
// ANALOG 7 : Reverberation Room size
//
// Available by OSC :  (see BELA console for precise adress)
// Rate         : Chorus LFO modulation rate (Hz)
// Deviation    : Chorus delay time deviation.
//
// InvertSum    : Phaser inversion of phaser in sum. (On/Off)
// VibratoMode  : Phaser vibrato Mode. (On/Off)
// Speed        : Phaser LFO frequency
// NotchDepth   : Phaser LFO depth
// Feedback     : Phaser Feedback
// NotchWidth   : Phaser Notch Width
// MinNotch1    : Phaser Minimal frequency
// MaxNotch1    : Phaser Maximal Frequency
//
// Damp         : Reverberation Damp
// Stereo       : Reverberation Stereo Width
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

process = chorus_stereo(dmax,curdel,rate,sigma,do2,voices) : phaserSt : xdelay : reverb;

// CHORUS (from SAM demo lib) //////////////////////////////////////////////////////////////////////////////////////////////////////////
voices = 8; // MUST BE EVEN

pi = 4.0*atan(1.0);
periodic  = 1;

dmax = 8192;
curdel = dmax * vslider(&quot;Delay[BELA: ANALOG_1]&quot;, 0.5, 0, 1, 1) : si.smooth(0.999);
rateMax = 7.0; // Hz
rateMin = 0.01;
rateT60 = 0.15661;

rate = vslider(&quot;Rate&quot;, 0.5, rateMin, rateMax, 0.0001): si.smooth(ba.tau2pole(rateT60/6.91));
depth = vslider(&quot;Depth [BELA: ANALOG_0]&quot;, 0.5, 0, 1, 0.001) : si.smooth(ba.tau2pole(depthT60/6.91));
// (dept = dry/wet)

depthT60 = 0.15661;
delayPerVoice = 0.5*curdel/voices;
sigma  = delayPerVoice * vslider(&quot;Deviation&quot;,0.5,0,1,0.001) : si.smooth(0.999);

do2 = depth;   // use when depth=1 means &quot;multivibrato&quot; effect (no original =&gt; all are modulated)

chorus_stereo(dmax,curdel,rate,sigma,do2,voices) =
      _,_ &lt;: *(1-do2),*(1-do2),(*(do2),*(do2) &lt;: par(i,voices,voice(i)):&gt;_,_) : ro.interleave(2,2) : +,+;
      voice(i) = de.fdelay(dmax,min(dmax,del(i)))/(i+1)
    with {
       angle(i) = 2*pi*(i/2)/voices + (i%2)*pi/2;
       voice(i) = de.fdelay(dmax,min(dmax,del(i))) * cos(angle(i));

         del(i) = curdel*(i+1)/voices + dev(i);
         rates(i) = rate/float(i+1);
         dev(i) = sigma *
             os.oscp(rates(i),i*2*pi/voices);
    };

// PHASER (from demo lib.) /////////////////////////////////////////////////////////////////////////////////////////////////////////////
phaserSt = _,_ &lt;: _, _, phaser2_stereo : dry_wetST(dwPhaz)
    with {

        invert = checkbox(&quot;InvertSum&quot;);
        vibr = checkbox(&quot;VibratoMode&quot;); // In this mode you can hear any &quot;Doppler&quot;

        phaser2_stereo = pf.phaser2_stereo(Notches,width,frqmin,fratio,frqmax,speed,mdepth,fb,invert);

        Notches = 4; // Compile-time parameter: 2 is typical for analog phaser stomp-boxes

        speed  = hslider(&quot;Speed&quot;, 0.5, 0, 10, 0.001);
        depth  = hslider(&quot;NotchDepth&quot;, 1, 0, 1, 0.001);
        fb     = hslider(&quot;Feedback&quot;, 0.7, -0.999, 0.999, 0.001);

        width  = hslider(&quot;NotchWidth&quot;,1000, 10, 5000, 1);
        frqmin = hslider(&quot;MinNotch1&quot;,100, 20, 5000, 1);
        frqmax = hslider(&quot;MaxNotch1&quot;,800, 20, 10000, 1) : max(frqmin);
        fratio = hslider(&quot;NotchFreqRatio[BELA: ANALOG_3]&quot;,1.5, 1.1, 4, 0.001);
        dwPhaz = vslider(&quot;dryWetPhaser[BELA: ANALOG_2]&quot;, 0.5, 0, 1, 0.001); 

        mdepth = select2(vibr,depth,2); // Improve &quot;ease of use&quot;
    };

// DELAY (with feedback and crossfeeback) //////////////////////////////////////////////////////////////////////////////////////////////
delay = ba.sec2samp(hslider(&quot;delay[BELA: ANALOG_5]&quot;, 1,0,2,0.001));
preDelL = delay/2;
delL    = delay;
delR    = delay;

crossLF = 1200;

CrossFeedb  = 0.6;
dwDel       = vslider(&quot;dryWetDelay[BELA: ANALOG_4]&quot;, 0.5, 0, 1, 0.001);

routeur(a,b,c,d) = ((a*CrossFeedb):fi.lowpass(2,crossLF))+c,
                    ((b*CrossFeedb):fi.lowpass(2,crossLF))+d;

xdelay = _,_ &lt;: _,_,((de.sdelay(65536, 512,preDelL),_):
        (routeur : de.sdelay(65536, 512,delL) ,de.sdelay(65536, 512,delR) ) ~ (_,_)) : dry_wetST(dwDel);

// REVERB (from freeverb_demo) /////////////////////////////////////////////////////////////////////////////////////////////////////////
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[BELA: ANALOG_7]&quot;, 0.5, 0, 1, 0.001)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo&quot;,0.5,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[BELA: ANALOG_6]&quot;, 0.2, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wetST(dw,x1,x2,y1,y2) = (wet*y1 + dry*x1),(wet*y2 + dry*x2)
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust14/exfaust14.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="graingenerator">GrainGenerator</h2>
<div class="faust-run"><a href="img/src/exfaust15/exfaust15-svg/process.svg" target="_blank"><img src="img/src/exfaust15/exfaust15-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Grain Generator.
// Another granular synthesis example.
// This one is not finished, but ready for more features and improvements...
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// ANALOG IN:
// ANALOG 0 : Population: 0=almost nothing. 1=Full grain
// ANALOG 1 : Depth of each grin, in ms.
// ANALOG 2 : Position in the table = delay 
// ANALOG 3 : Speed = pitch change of the grains
// ANALOG 4 : Feedback
//
///////////////////////////////////////////////////////////////////////////////////////////////////

import(&quot;all.lib&quot;);

// FOR 4 grains - MONO

// UI //////////////////////////////////////////
popul = 1 - hslider(&quot;population[BELA: ANALOG_0]&quot;, 1, 0, 1, 0.001);  // Coef 1= maximum; 0 = almost nothing (0.95)
taille = hslider(&quot;taille[BELA: ANALOG_1]&quot;, 100, 4, 200, 0.001 );        // Size in millisecondes
decal = 1 - hslider(&quot;decal[BELA: ANALOG_2]&quot;,0,0,1,0.001);               // read position compared to table srite position

speed = hslider(&quot;speed[BELA: ANALOG_3]&quot;, 1, 0.125, 4, 0.001);

feedback = hslider(&quot;feedback[BELA: ANALOG_4]&quot;,0,0,2,0.001); 

freq = 1000/taille;
tmpTaille = taille*ma.SR/ 1000;
clocSize = int(tmpTaille + (tmpTaille*popul*10)); // duration between 2 clicks

// CLK GENERAL /////////////////////////////////
// 4 clicks vers 4 generateurs de grains.
// (idem clk freq/4 et un compteur...)
detect1(x) = select2 (x &lt; 10, 0, 1);
detect2(x) = select2 (x &gt; clocSize*1/3, 0, 1) : select2 (x &lt; (clocSize*1/3)+10, 0, _);
detect3(x) = select2 (x &gt; clocSize*2/3, 0, 1) : select2 (x &lt; (clocSize*2/3)+10, 0, _);
detect4(x) = select2 (x &gt; clocSize-10, 0, 1);
cloc = (%(_,clocSize))~(+(1)) &lt;: (detect1: trig),(detect2: trig),(detect3: trig),(detect4: trig);

// SIGNAUX Ctrls Player ////////////////////////
trig = _&lt;:_,mem: &gt;;
envelop = *(2*PI):+(PI):cos:*(0.5):+(0.5);

rampe(f, t) = delta : (+ : select2(t,_,delta&lt;0) : max(0)) ~ _ : raz
    with {
        raz(x) = select2 (x &gt; 1, x, 0);
        delta = sh(f,t)/ma.SR;
        sh(x,t) = ba.sAndH(t,x);
    };

rampe2(speed, t) = delta : (+ : select2(t,_,delta&lt;0) : max(0)) ~ _ 
    with {
        delta = sh(speed,t);
        sh(x,t) = ba.sAndH(t,x);
    };

// RWTable //////////////////////////////////////
unGrain(input, clk) = (linrwtable( wf , rindex) : *(0.2 * EnvGrain))
    with {
        SR = 44100;
        buffer_sec = 1;
        size = int(SR * buffer_sec);
        init = 0.;

        EnvGrain = clk : (rampe(freq) : envelop);   

        windex = (%(_,size) ) ~ ( +(1) );
        posTabl = int(ba.sAndH(clk, windex));
        rindex = %(int(rampe2(speed, clk)) + posTabl + int(size * decal), size);

        wf = size, init, int(windex), input;
    };

// LINEAR_INTERPOLATION_RWTABLE //////////////////////////////////
// read rwtable with linear interpolation
// wf : waveform to read ( wf is defined by (size_buffer,init, windex, input ))
// x  : position to read (0 &lt;= x &lt; size(wf)) and float
// nota: rwtable(size, init, windex, input, rindex)

linrwtable(wf,x) = linterpolation(y0,y1,d)
    with {
        x0 = int(x);                //
        x1 = int(x+1);              //
        d  = x-x0;
        y0 = rwtable(wf,x0);        //
        y1 = rwtable(wf,x1);        //
        linterpolation(v0,v1,c) = v0*(1-c)+v1*c;
    };

// FINALISATION /////////////////////////////////////////////////////////////////////////////////////
routeur (a, b, c, d, e) = a, b, a, c, a, d, a, e;

processus = _ , cloc : routeur : (unGrain, unGrain, unGrain, unGrain) :&gt; fi.dcblockerat(20);
process = _,_: ((+(_,_) :processus) ~(*(feedback))),((+(_,_) :processus) ~(*(feedback)));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust15/exfaust15.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="granulator">granulator</h2>
<div class="faust-run"><a href="img/src/exfaust16/exfaust16-svg/process.svg" target="_blank"><img src="img/src/exfaust16/exfaust16-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// FROM FAUST DEMO
// Designed to use the Analog Input for parameters contrôles.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// ANALOG IN:
// ANALOG 0 : Grain Size
// ANALOG 1 : Speed
// ANALOG 2 : Probability
// (others analog inputs are not used)
//
///////////////////////////////////////////////////////////////////////////////////////////////////

process = vgroup(&quot;Granulator&quot;, environment {
    declare name &quot;Granulator&quot;;
    declare author &quot;Adapted from sfIter by Christophe Lebreton&quot;;

    /* =========== DESCRIPTION =============

    - The granulator takes very small parts of a sound, called GRAINS, and plays them at a varying speed
    - Front = Medium size grains
    - Back = short grains
    - Left Slow rhythm
    - Right = Fast rhythm
    - Bottom = Regular occurrences
    - Head = Irregular occurrences 
    */

    import(&quot;stdfaust.lib&quot;);

    process = hgroup(&quot;Granulator&quot;, *(excitation : ampf));

    excitation = noiseburst(gate,P) * (gain);
    ampf = an.amp_follower_ud(duree_env,duree_env);

    //----------------------- NOISEBURST ------------------------- 

    noiseburst(gate,P) = no.noise : *(gate : trigger(P))
        with { 
            upfront(x) = (x-x&#39;) &gt; 0;
            decay(n,x) = x - (x&gt;0)/n; 
            release(n) = + ~ decay(n); 
            trigger(n) = upfront : release(n) : &gt; (0.0);
        };

    //-------------------------------------------------------------

    P = freq; // fundamental period in samples
    freq = hslider(&quot;[1]GrainSize[BELA: ANALOG_0]&quot;, 200,5,2205,1);
    // la frequence donne la largeur de bande extraite du bruit blanc
    Pmax = 4096; // maximum P (for de.delay-line allocation)

    // PHASOR_BIN //////////////////////////////
    phasor_bin (init) =  (+(float(speed)/float(ma.SR)) : fmod(_,1.0)) ~ *(init);
    gate = phasor_bin(1) :-(0.001):pulsar;
    gain = 1;
                            
    // PULSAR //////////////////////////////
    //Le pulsar permet de creer une &#39;pulsation&#39; plus ou moins aleatoire (proba).

    pulsar = _&lt;:((_&lt;(ratio_env)):@(100))*(proba&gt;(_,abs(no.noise):ba.latch)); 
    speed = hslider (&quot;[2]Speed[BELA: ANALOG_1]&quot;, 10,1,20,0.0001):fi.lowpass(1,1);

    ratio_env = 0.5;
    fade = (0.5); // min &gt; 0 pour eviter division par 0

    proba = hslider (&quot;[3]Probability[BELA: ANALOG_2]&quot;, 70,50,100,1) * (0.01):fi.lowpass(1,1);
    duree_env = 1/(speed: / (ratio_env*(0.25)*fade));
}.process);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust16/exfaust16.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="repeater">repeater</h2>
<div class="faust-run"><a href="img/src/exfaust17/exfaust17-svg/process.svg" target="_blank"><img src="img/src/exfaust17/exfaust17-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// REPEATER:
// Freeze and repeat a small part of input signal &#39;n&#39; time&#39;
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// ANALOG IN:
// ANALOG 0 : Duration (ms) between 2 repeat series (500 to 2000 ms)
// ANALOG 1 : Duration of one repeat (2 to 200 ms)
// ANALOG 2 : Number of repeat
//
///////////////////////////////////////////////////////////////////////////////////////////////////

import(&quot;all.lib&quot;);

process = _, _ , (pathClock : compteurUpReset2(nbRepet): rampePlayer, _) : routageIO : rec_play_table , rec_play_table;

///////////////////////////////////////////////////////////////////////////////////////////////////

// General loop duration
MasterTaille =hslider(&quot;MasterTaille[BELA: ANALOG_0]&quot;, 500, 200, 2000,0.01);
MasterClocSize = int(MasterTaille*ma.SR/ 1000);

// Depth of repeat fragments
taille =hslider(&quot;taille[BELA: ANALOG_1]&quot;, 50, 2, 200,0.01);
clocSize = int(taille*ma.SR/ 1000);

// Number of repeat fragments
nbRepet = int (hslider(&quot;nbRepet[BELA: ANALOG_2]&quot;,4,1,16,1) );

trig = _&lt;:_,mem: &gt;;

routageIO (a, b, c, d) = a, c, d, b, c, d;
rec_play_table(input, inReadIndex, reset) = ( rwtable( wf , rindex):fi.dcblockerat(20) )
    with {
        SR = 44100;
        buffer_sec = 2;
        size = int(SR * buffer_sec);
        init = 0.;

        windex = (%(_,size))~(+(1):*(1-reset)); 
        rindex = (%( int(inReadIndex),size));

        wf = size, init, int(windex), input;
    };

MasterClock = (%(_,MasterClocSize))~(+(1)) : detect
    with {
        detect(x) = select2 (x &lt; 100, 0, 1);
    };

SlaveClock(reset) = (%(_,clocSize))~(+(1):*(1-reset));
detect1(x) = select2 (x &lt; clocSize/2, 0, 1);

pathClock = MasterClock &lt;: trig, _ : SlaveClock, _ : detect1, _ ;

compteurUpReset2(nb, in, reset) = ((in:trig), reset : (routage : memo2)~_), reset
    with {
        memo2(a, b)     = (ba.if(b&gt;0.5, 0, _) )~(+(a));
        compare(value)  = ba.if(value&gt;nb, 1, 0); // :trig;
        routage(d,e,f)  = e , (f, compare(d) : RSLatch &lt;: +(f));
    };

RSLatch(R, S) = latch(S,R)
    with {
        trig = _&lt;:_,mem: &gt;;
        latch(S,R) = _~( ba.if(R&gt;0.5, 0, _) : ba.if(S&gt;0.5,1,_) );
    };

rampePlayer(reset) = rampe
    with {
        rst = reset : trig;
        rampe = _~(+(1):*(1-rst));
        toZero = _ : ba.if(reset&lt;0.5,0,_);
    };</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust17/exfaust17.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="simplefx_analog">simpleFX_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust18/exfaust18-svg/process.svg" target="_blank"><img src="img/src/exfaust18/exfaust18-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
// This version use ANALOG IN to controle some of the parameters.
// Other parameters continue to be available by MIDI or OSC.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_4 : Distortion Drive
// ANALOG_5 : Flanger Dry/Wet
// ANALOG_6 : Reverberation Dry/Wet
// ANALOG_7 : Reverberation Room size
//
// MIDI:
// CC 7  : Volume
// CC 10 : Pan
//
// CC 13 : Flanger Delay
// CC 13 : Flanger Delay
// CC 94 : Flanger Feedback
//
// CC 95 : Reverberation Damp
// CC 90: Reverberation Stereo Width
// 
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
vol = hslider(&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive   = hslider (&quot;drive[BELA: ANALOG_4]&quot;,0.3,0,1,0.001);

// Flanger
curdel  = hslider(&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb      = hslider(&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw    = hslider(&quot;dryWetFlang[BELA: ANALOG_5]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[BELA: ANALOG_7]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[BELA: ANALOG_6]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effets = _ *(vol) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

process = effets;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust18/exfaust18.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="simplefx">simpleFX</h2>
<div class="faust-run"><a href="img/src/exfaust19/exfaust19-svg/process.svg" target="_blank"><img src="img/src/exfaust19/exfaust19-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
// (All are available by OSC)
//
// CC 7  : Volume
// CC 10 : Pan
//
// CC 92 : Distortion Drive
//
// CC 13 : Flanger Delay
// CC 93 : Flanger Dry/Wet
// CC 94 : Flanger Feedback
//
// CC 12 : Reverberation Room size
// CC 91 : Reverberation Dry/Wet
// CC 95 : Reverberation Damp
// CC 90 : Reverberation Stereo Width
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
vol = hslider (&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive = hslider (&quot;drive[midi:ctrl 92]&quot;,0.3,0,1,0.001);

// Flanger
curdel = hslider (&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb = hslider (&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw = hslider (&quot;dryWetFlang[midi:ctrl 93]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Panoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[midi:ctrl 12]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[midi:ctrl 91]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effets = _ *(vol) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

process = effets;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust19/exfaust19.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="simplesynth_analog">simpleSynth_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust20/exfaust20-svg/process.svg" target="_blank"><img src="img/src/exfaust20/exfaust20-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// A very simple subtractive synthesizer with 1 VCO 1 VCF.
// The VCO Waveform is variable between Saw and Square
// The frequency is modulated by an LFO
// The envelope control volum and filter frequency
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : waveform (Saw to square)
// ANALOG_1 : Filter Cutoff frequency
// ANALOG_2 : Filter resonance (Q)
// ANALOG_3 : Filter Envelope Modulation
//
// MIDI:
// CC 79 : Filter keyboard tracking (0 to X2, default 1)
//
// Envelope
// CC 73 : Attack
// CC 76 : Decay
// CC 77 : Sustain
// CC 72 : Release
//
// CC 78 : LFO frequency (0.001Hz to 10Hz)
// CC 1  : LFO Amplitude (Modulation)
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// HUI //////////////////////////////////////////////////
// Keyboard
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

// VCO
wfFade = hslider(&quot;waveform[BELA: ANALOG_0]&quot;,0.5,0,1,0.001):si.smoo;

// VCF
res = hslider(&quot;resonnance[BELA: ANALOG_2]&quot;,0.5,0,1,0.001):si.smoo;
fr = hslider(&quot;fc[BELA: ANALOG_1]&quot;, 10, 15, 12000, 0.001):si.smoo;
track = hslider(&quot;tracking[midi:ctrl 79]&quot;, 1, 0, 2, 0.001);
envMod = hslider(&quot;envMod[BELA: ANALOG_3]&quot;,50,0,100,0.01):si.smoo;

// ENV
att = 0.01 * (hslider (&quot;attack[midi:ctrl 73]&quot;,0.1,0.1,400,0.001));
dec = 0.01 * (hslider (&quot;decay[midi:ctrl 76]&quot;,60,0.1,400,0.001));
sust = hslider (&quot;sustain[midi:ctrl 77]&quot;,0.2,0,1,0.001);
rel = 0.01 * (hslider (&quot;release[midi:ctrl 72]&quot;,100,0.1,400,0.001));

// LFO
lfoFreq = hslider (&quot;lfoFreq[midi:ctrl 78]&quot;,6,0.001,10,0.001):si.smoo;
modwheel = hslider (&quot;modwheel[midi:ctrl 1]&quot;,0,0,0.5,0.001):si.smoo;

// PROCESS /////////////////////////////////////////////
allfreq = (midifreq * pitchwheel) + LFO;
// VCF
cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8);

// VCO
oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade);

// VCA
volume = midigain * env;

// Enveloppe
env = en.adsre(att,dec,sust,rel,midigate);

// LFO
LFO = os.lf_triangle(lfoFreq)*modwheel*10;

// SYNTH ////////////////////////////////////////////////
synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume;

// PROCESS /////////////////////////////////////////////
process = synth;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust20/exfaust20.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="simplesynth">simpleSynth</h2>
<div class="faust-run"><a href="img/src/exfaust21/exfaust21-svg/process.svg" target="_blank"><img src="img/src/exfaust21/exfaust21-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// A very simple subtractive synthesizer with 1 VCO 1 VCF.
// The VCO Waveform is variable between Saw and Square
// The frequency is modulated by an LFO
// The envelope control volum and filter frequency
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
//
// CC 70 : waveform (Saw to square)
// CC 71 : Filter resonance (Q)
// CC 74 : Filter Cutoff frequency
// CC 79 : Filter keyboard tracking (0 to X2, default 1)
// CC 75 : Filter Envelope Modulation
//
// Envelope
// CC 73 : Attack
// CC 76 : Decay
// CC 77 : Sustain
// CC 72 : Release
//
// CC 78 : LFO frequency (0.001Hz to 10Hz)
// CC 1 : LFO Amplitude (Modulation)
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// HUI //////////////////////////////////////////////////
// Keyboard
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

// VCO
wfFade= hslider(&quot;waveform[midi:ctrl 70]&quot;,0.5,0,1,0.001):si.smoo;

// VCF
res = hslider(&quot;resonnance[midi:ctrl 71]&quot;,0.5,0,1,0.001):si.smoo;
fr = hslider(&quot;fc[midi:ctrl 74]&quot;, 10, 15, 12000, 0.001):si.smoo;
track = hslider(&quot;tracking[midi:ctrl 79]&quot;, 1, 0, 2, 0.001);
envMod  = hslider(&quot;envMod[midi:ctrl 75]&quot;,50,0,100,0.01):si.smoo; 

// ENV
att = 0.01 * (hslider (&quot;attack[midi:ctrl 73]&quot;,0.1,0.1,400,0.001));
dec = 0.01 * (hslider (&quot;decay[midi:ctrl 76]&quot;,60,0.1,400,0.001));
sust = hslider (&quot;sustain[midi:ctrl 77]&quot;,0.1,0,1,0.001);
rel = 0.01 * (hslider (&quot;release[midi:ctrl 72]&quot;,100,0.1,400,0.001));

// LFO
lfoFreq = hslider(&quot;lfoFreq[midi:ctrl 78]&quot;,6,0.001,10,0.001):si.smoo;
modwheel = hslider(&quot;modwheel[midi:ctrl 1]&quot;,0,0,0.5,0.001):si.smoo;

// PROCESS /////////////////////////////////////////////
allfreq = (midifreq * pitchwheel) + LFO;
// VCF
cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8);

// VCO
oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade);

// VCA
volume = midigain * env;

// Enveloppe
env = en.adsre(att,dec,sust,rel,midigate);

// LFO
LFO = os.lf_triangle(lfoFreq)*modwheel*10;

// SYNTH ////////////////////////////////////////////////
synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume;

// PROCESS /////////////////////////////////////////////
process = synth;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust21/exfaust21.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="simplesynth_fx_analog">simpleSynth_FX_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust22/exfaust22-svg/process.svg" target="_blank"><img src="img/src/exfaust22/exfaust22-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// A very simple subtractive synthesizer with 1 VCO 1 VCF.
// The VCO Waveform is variable between Saw and Square
// The frequency is modulated by an LFO
// The envelope control volum and filter frequency
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : waveform (Saw to square)
// ANALOG_1 : Filter Cutoff frequency
// ANALOG_2 : Filter resonance (Q)
// ANALOG_3 : Filter Envelope Modulation
//
// MIDI:
// CC 79    : Filter keyboard tracking (0 to X2, default 1)
//
// Envelope
// CC 73    : Attack
// CC 76    : Decay
// CC 77    : Sustain
// CC 72    : Release
//
// CC 78    : LFO frequency (0.001Hz to 10Hz)
// CC 1     : LFO Amplitude (Modulation)
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// HUI //////////////////////////////////////////////////
// Keyboard
midigate = button(&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

// VCO
wfFade = hslider(&quot;waveform[BELA: ANALOG_0]&quot;,0.5,0,1,0.001):si.smoo;

// VCF
res = hslider(&quot;resonnance[BELA: ANALOG_2]&quot;,0.5,0,1,0.001):si.smoo;
fr = hslider(&quot;fc[BELA: ANALOG_1]&quot;, 10, 15, 12000, 0.001):si.smoo;
track = hslider(&quot;tracking[midi:ctrl 79]&quot;, 1, 0, 2, 0.001);
envMod  = hslider(&quot;envMod[BELA: ANALOG_3]&quot;,50,0,100,0.01):si.smoo; 

// ENV
att = 0.01 * (hslider (&quot;attack[midi:ctrl 73]&quot;,0.1,0.1,400,0.001));
dec = 0.01 * (hslider (&quot;decay[midi:ctrl 76]&quot;,60,0.1,400,0.001));
sust = hslider (&quot;sustain[midi:ctrl 77]&quot;,0.2,0,1,0.001);
rel = 0.01 * (hslider (&quot;release[midi:ctrl 72]&quot;,100,0.1,400,0.001));

// LFO
lfoFreq = hslider(&quot;lfoFreq[midi:ctrl 78]&quot;,6,0.001,10,0.001):si.smoo;
modwheel = hslider(&quot;modwheel[midi:ctrl 1]&quot;,0,0,0.5,0.001):si.smoo;

// PROCESS /////////////////////////////////////////////
allfreq = (midifreq * pitchwheel) + LFO;
// VCF
cutoff = ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8);

// VCO
oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade);

// VCA
volume = midigain * env;

// Enveloppe
env = en.adsre(att,dec,sust,rel,midigate);

// LFO
LFO = os.lf_triangle(lfoFreq)*modwheel*10;

// SYNTH ////////////////////////////////////////////////
synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume;

//#################################################################################################//
//##################################### EFFECT SECTION ############################################//
//#################################################################################################//
//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
// This version use ANALOG IN to controle some of the parameters.
// Other parameters continue to be available by MIDI or OSC.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_4 : Distortion Drive
// ANALOG_5 : Flanger Dry/Wet
// ANALOG_6 : Reverberation Dry/Wet
// ANALOG_7 : Reverberation Room size
//
// MIDI:
// CC 7     : Volume
// CC 10    : Pan
//
// CC 13    : Flanger Delay
// CC 13    : Flanger Delay
// CC 94    : Flanger Feedback
//
// CC 95    : Reverberation Damp
// CC 90    : Reverberation Stereo Width
// 
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
volFX   = hslider (&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive   = hslider (&quot;drive[BELA: ANALOG_4]&quot;,0.3,0,1,0.001);


// Flanger
curdel  = hslider (&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb      = hslider (&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw    = hslider (&quot;dryWetFlang[BELA: ANALOG_5]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[BELA: ANALOG_7]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[BELA: ANALOG_6]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

// PROCESS /////////////////////////////////////////////
process = synth;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust22/exfaust22.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="simplesynth_fx">simpleSynth_FX</h2>
<div class="faust-run"><a href="img/src/exfaust23/exfaust23-svg/process.svg" target="_blank"><img src="img/src/exfaust23/exfaust23-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// A very simple subtractive synthesizer with 1 VCO 1 VCF.
// The VCO Waveform is variable between Saw and Square
// The frequency is modulated by an LFO
// The envelope control volum and filter frequency
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
//
// CC 70 : waveform (Saw to square)
// CC 71 : Filter resonance (Q)
// CC 74 : Filter Cutoff frequency
// CC 79 : Filter keyboard tracking (0 to X2, default 1)
// CC 75 : Filter Envelope Modulation
//
// Envelope
// CC 73 : Attack
// CC 76 : Decay
// CC 77 : Sustain
// CC 72 : Release
//
// CC 78 : LFO frequency (0.001Hz to 10Hz)
// CC 1 : LFO Amplitude (Modulation)
//
///////////////////////////////////////////////////////////////////////////////////////////////////
//
// HUI //////////////////////////////////////////////////
// Keyboard
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 0.5, 0.01);// MIDI KEYBOARD

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

// VCO
wfFade = hslider(&quot;waveform[midi:ctrl 70]&quot;,0.5,0,1,0.001):si.smoo;

// VCF
res = hslider(&quot;resonnance[midi:ctrl 71]&quot;,0.5,0,1,0.001):si.smoo;
fr = hslider(&quot;fc[midi:ctrl 74]&quot;, 10, 15, 12000, 0.001):si.smoo;
track = hslider(&quot;tracking[midi:ctrl 79]&quot;, 1, 0, 2, 0.001);
envMod  = hslider(&quot;envMod[midi:ctrl 75]&quot;,50,0,100,0.01):si.smoo; 

// ENV
att = 0.01 * (hslider (&quot;attack[midi:ctrl 73]&quot;,0.1,0.1,400,0.001));
dec = 0.01 * (hslider (&quot;decay[midi:ctrl 76]&quot;,60,0.1,400,0.001));
sust = hslider (&quot;sustain[midi:ctrl 77]&quot;,0.1,0,1,0.001);
rel = 0.01 * (hslider (&quot;release[midi:ctrl 72]&quot;,100,0.1,400,0.001));

// LFO
lfoFreq = hslider (&quot;lfoFreq[midi:ctrl 78]&quot;,6,0.001,10,0.001):si.smoo;
modwheel= hslider (&quot;modwheel[midi:ctrl 1]&quot;,0,0,0.5,0.001):si.smoo;

// PROCESS /////////////////////////////////////////////
allfreq = (midifreq * pitchwheel) + LFO;

// VCF
cutoff= ((allfreq * track) + fr + (envMod * midigain * env)) : min(ma.SR/8);

// VCO
oscillo(f) = (os.sawtooth(f)*(1-wfFade))+(os.square(f)*wfFade);

// VCA
volume = midigain * env;

// Enveloppe
env = en.adsre(att,dec,sust,rel,midigate);

// LFO
LFO = os.lf_triangle(lfoFreq)*modwheel*10;

// SYNTH ////////////////////////////////////////////////
synth = (oscillo(allfreq) :ve.moog_vcf(res,cutoff)) * volume;

//#################################################################################################//
//##################################### EFFECT SECTION ############################################//
//#################################################################################################//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
// (All are available by OSC)
//
// CC 7 : Volume
// CC 10 : Pan
//
// CC 92 : Distortion Drive
//
// CC 13 : Flanger Delay
// CC 93 : Flanger Dry/Wet
// CC 94 : Flanger Feedback
//
// CC 12 : Reverberation Room size
// CC 91 : Reverberation Dry/Wet
// CC 95 : Reverberation Damp
// CC 90 : Reverberation Stereo Width
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
volFX = hslider (&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive = hslider (&quot;drive[midi:ctrl 92]&quot;,0.3,0,1,0.001);

// Flanger
curdel = hslider (&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb = hslider (&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw = hslider (&quot;dryWetFlang[midi:ctrl 93]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[midi:ctrl 12]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[midi:ctrl 91]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

// PROCESS /////////////////////////////////////////////
process = synth;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust23/exfaust23.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="wavesynth_analog">WaveSynth_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust24/exfaust24-svg/process.svg" target="_blank"><img src="img/src/exfaust24/exfaust24-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables.
// It&#39;s possible to add more tables step.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : Wave travelling
// ANALOG_1 : LFO Frequency
// ANALOG_2 : LFO Depth (wave travel modulation)
// ANALOG_3 : Release
//
// MIDI:
// CC 73 : Attack
// CC 76 : Decay
// CC 77 : Sustain
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERAL
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain  = nentry(&quot;gain&quot;, 0.5, 0, 1, 0.01);

waveTravel = hslider(&quot;waveTravel[BELA: ANALOG_0]&quot;,0,0,1,0.01);

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

// LFO
lfoDepth = hslider(&quot;lfoDepth[BELA: ANALOG_2]&quot;,0,0.,1,0.001):si.smoo;
lfoFreq  = hslider(&quot;lfoFreq[BELA: ANALOG_1]&quot;,0.1,0.01,10,0.001):si.smoo;
moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0);

volA = hslider(&quot;A[midi:ctrl 73]&quot;,0.01,0.01,4,0.01);
volD = hslider(&quot;D[midi:ctrl 76]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[midi:ctrl 77]&quot;,0.2,0,1,0.01);
volR = hslider(&quot;R[BELA: ANALOG_3]&quot;,0.8,0.01,8,0.01);
envelop = en.adsre(volA,volD,volS,volR,midigate);

// Out Amplitude
vol = envelop * midigain;

WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.;

// 4 WF maxi with this version:
scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0)
    with {
        coef = 3.14159 * ((nb-1)*0.5);
        soustraction = select2( position&gt;0, 0, (position/(nb-1)) );
    };

wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1)))
            + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3)))
    with {
        tablesize = 1024;
        wt1 = WF(tablesize, 16);
        wt2 = WF(tablesize, 8);
        wt3 = WF(tablesize, 6);
        wt4 = WF(tablesize, 4);
        faze = int(os.phasor(tablesize,freq));
    };

process = wfosc(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust24/exfaust24.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="wavesynth">WaveSynth</h2>
<div class="faust-run"><a href="img/src/exfaust25/exfaust25-svg/process.svg" target="_blank"><img src="img/src/exfaust25/exfaust25-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables.
// It&#39;s possible to add more tables step.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
//
// CC 1 : LFO Depth (wave travel modulation)
// CC 14 : LFO Frequency
// CC 70 : Wave travelling
//
// CC 73 : Attack
// CC 76 : Decay
// CC 77 : Sustain
// CC 72 : Release
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERAL
midigate = button (&quot;gate&quot;);
midifreq = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain = nentry(&quot;gain&quot;, 0.5, 0, 1, 0.01);

waveTravel = hslider(&quot;waveTravel [midi:ctrl ]&quot;,0,0,1,0.01);

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

// LFO
lfoDepth = hslider (&quot;lfoDepth[midi:ctrl 1]&quot;,0,0.,1,0.001):si.smoo;
lfoFreq  = hslider (&quot;lfoFreq[midi:ctrl 14]&quot;,0.1,0.01,10,0.001):si.smoo;
moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0);

volA = hslider(&quot;A[midi:ctrl 73]&quot;,0.01,0.01,4,0.01);
volD = hslider(&quot;D[midi:ctrl 76]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[midi:ctrl 77]&quot;,0.2,0,1,0.01);
volR = hslider(&quot;R[midi:ctrl 72]&quot;,0.8,0.01,8,0.01);
envelop = en.adsre(volA,volD,volS,volR,midigate);

// Out Amplitude
vol = envelop * midigain ;

WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.;

// 4 WF maxi with this version:
scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0)
with{
    coef = 3.14159 * ((nb-1)*0.5);
    soustraction = select2( position&gt;0, 0, (position/(nb-1)) );
};

wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1)))
                + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3)))
with {
    tablesize = 1024;
    wt1 = WF(tablesize, 16);
    wt2 = WF(tablesize, 8);
    wt3 = WF(tablesize, 6);
    wt4 = WF(tablesize, 4);
    faze = int(os.phasor(tablesize,freq));
};

process = wfosc(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust25/exfaust25.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="wavesynth_fx_analog">WaveSynth_FX_Analog</h2>
<div class="faust-run"><a href="img/src/exfaust26/exfaust26-svg/process.svg" target="_blank"><img src="img/src/exfaust26/exfaust26-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables.
// It&#39;s possible to add more tables step.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_0 : Wave travelling
// ANALOG_1 : LFO Frequency
// ANALOG_2 : LFO Depth (wave travel modulation)
// ANALOG_3 : Release
//
// MIDI:
// CC 73    : Attack
// CC 76    : Decay
// CC 77    : Sustain
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERAL
midigate        = button (&quot;gate&quot;);
midifreq        = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain        = nentry(&quot;gain&quot;, 0.5, 0, 1, 0.01);

waveTravel      = hslider(&quot;waveTravel[BELA: ANALOG_0]&quot;,0,0,1,0.01);

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

// LFO
lfoDepth = hslider(&quot;lfoDepth[BELA: ANALOG_2]&quot;,0,0.,1,0.001):si.smoo;
lfoFreq  = hslider(&quot;lfoFreq[BELA: ANALOG_1]&quot;,0.1,0.01,10,0.001):si.smoo;
moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0);

volA = hslider(&quot;A[midi:ctrl 73]&quot;,0.01,0.01,4,0.01);
volD = hslider(&quot;D[midi:ctrl 76]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[midi:ctrl 77]&quot;,0.2,0,1,0.01);
volR = hslider(&quot;R[BELA: ANALOG_3]&quot;,0.8,0.01,8,0.01);
envelop = en.adsre(volA,volD,volS,volR,midigate);

// Out Amplitude
vol = envelop * midigain ;

WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.;

// 4 WF maxi with this version:
scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0)
    with {
        coef = 3.14159 * ((nb-1)*0.5);
        soustraction = select2( position&gt;0, 0, (position/(nb-1)) );
    };

wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1)))
                + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3)))
    with {
        tablesize = 1024;
        wt1 = WF(tablesize, 16);
        wt2 = WF(tablesize, 8);
        wt3 = WF(tablesize, 6);
        wt4 = WF(tablesize, 4);
        faze = int(os.phasor(tablesize,freq));
    };

//#################################################################################################//
//##################################### EFFECT SECTION ############################################//
//#################################################################################################//
//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
// This version use ANALOG IN to controle some of the parameters.
// Other parameters continue to be available by MIDI or OSC.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// ANALOG IMPLEMENTATION:
//
// ANALOG_4 : Distortion Drive
// ANALOG_5 : Flanger Dry/Wet
// ANALOG_6 : Reverberation Dry/Wet
// ANALOG_7 : Reverberation Room size
//
// MIDI:
// CC 7 : Volume
// CC 10 : Pan
//
// CC 13 : Flanger Delay
// CC 13 : Flanger Delay
// CC 94 : Flanger Feedback
//
// CC 95 : Reverberation Damp
// CC 90 : Reverberation Stereo Width
// 
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
volFX = hslider(&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive = hslider (&quot;drive[BELA: ANALOG_4]&quot;,0.3,0,1,0.001);

// Flanger
curdel  = hslider(&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb = hslider(&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw = hslider(&quot;dryWetFlang[BELA: ANALOG_5]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[BELA: ANALOG_7]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[BELA: ANALOG_6]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

process = wfosc(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust26/exfaust26.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="wavesynth_fx">WaveSynth_FX</h2>
<div class="faust-run"><a href="img/src/exfaust27/exfaust27-svg/process.svg" target="_blank"><img src="img/src/exfaust27/exfaust27-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);

///////////////////////////////////////////////////////////////////////////////////////////////////
//
// Simple demo of wavetable synthesis. A LFO modulate the interpolation between 4 tables.
// It&#39;s possible to add more tables step.
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
//
// CC 1     : LFO Depth (wave travel modulation)
// CC 14    : LFO Frequency
// CC 70    : Wave travelling
//
// CC 73    : Attack
// CC 76    : Decay
// CC 77    : Sustain
// CC 72    : Release
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// GENERAL
midigate        = button (&quot;gate&quot;);
midifreq        = nentry(&quot;freq[unit:Hz]&quot;, 440, 20, 20000, 1);
midigain        = nentry(&quot;gain&quot;, 0.5, 0, 1, 0.01);

waveTravel      = hslider(&quot;waveTravel [midi:ctrl ]&quot;,0,0,1,0.01);

// pitchwheel
pitchwheel = hslider(&quot;bend [midi:pitchwheel]&quot;,1,0.001,10,0.01);

gFreq = midifreq * pitchwheel;

// LFO
lfoDepth = hslider(&quot;lfoDepth[midi:ctrl 1]&quot;,0,0.,1,0.001):si.smoo;
lfoFreq  = hslider(&quot;lfoFreq[midi:ctrl 14]&quot;,0.1,0.01,10,0.001):si.smoo;
moov = ((os.lf_trianglepos(lfoFreq) * lfoDepth) + waveTravel) : min(1) : max(0);

volA = hslider(&quot;A[midi:ctrl 73]&quot;,0.01,0.01,4,0.01);
volD = hslider(&quot;D[midi:ctrl 76]&quot;,0.6,0.01,8,0.01);
volS = hslider(&quot;S[midi:ctrl 77]&quot;,0.2,0,1,0.01);
volR = hslider(&quot;R[midi:ctrl 72]&quot;,0.8,0.01,8,0.01);
envelop = en.adsre(volA,volD,volS,volR,midigate);

// Out Amplitude
vol = envelop * midigain ;

WF(tablesize, rang) = abs((fmod ((1+(float(ba.time)*rang)/float(tablesize)), 4.0 ))-2) -1.;

// 4 WF maxi with this version:
scanner(nb, position) = -(_,soustraction) : *(_,coef) : cos : max(0)
    with {
        coef = 3.14159 * ((nb-1)*0.5);
        soustraction = select2( position&gt;0, 0, (position/(nb-1)) );
    };

wfosc(freq) = (rdtable(tablesize, wt1, faze)*(moov : scanner(4,0)))+(rdtable(tablesize, wt2, faze)*(moov : scanner(4,1)))
                + (rdtable(tablesize, wt3, faze)*(moov : scanner(4,2)))+(rdtable(tablesize, wt4, faze)*(moov : scanner(4,3)))
    with {
        tablesize = 1024;
        wt1 = WF(tablesize, 16);
        wt2 = WF(tablesize, 8);
        wt3 = WF(tablesize, 6);
        wt4 = WF(tablesize, 4);
        faze = int(os.phasor(tablesize,freq));
    };

//#################################################################################################//
//##################################### EFFECT SECTION ############################################//
//#################################################################################################//
// Simple FX chaine build for a mono synthesizer.
// It controle general volume and pan.
// FX Chaine is:
//      Drive
//      Flanger
//      Reverberation
//
///////////////////////////////////////////////////////////////////////////////////////////////////
// MIDI IMPLEMENTATION:
// (All are available by OSC)
//
// CC 7 : Volume
// CC 10 : Pan
//
// CC 92 : Distortion Drive
//
// CC 13 : Flanger Delay
// CC 93 : Flanger Dry/Wet
// CC 94 : Flanger Feedback
//
// CC 12 : Reverberation Room size
// CC 91 : Reverberation Dry/Wet
// CC 95 : Reverberation Damp
// CC 90 : Reverberation Stereo Width
//
///////////////////////////////////////////////////////////////////////////////////////////////////

// VOLUME:
volFX = hslider(&quot;volume[midi:ctrl 7]&quot;,1,0,1,0.001);// Should be 7 according to MIDI CC norm.

// EFFECTS /////////////////////////////////////////////
drive   = hslider (&quot;drive[midi:ctrl 92]&quot;,0.3,0,1,0.001);

// Flanger
curdel  = hslider(&quot;flangDel[midi:ctrl 13]&quot;,4,0.001,10,0.001);
fb = hslider(&quot;flangFeedback[midi:ctrl 94]&quot;,0.7,0,1,0.001);
fldw = hslider(&quot;dryWetFlang[midi:ctrl 93]&quot;,0.5,0,1,0.001);
flanger = efx
    with {
        fldel = (curdel + (os.lf_triangle(1) * 2) ) : min(10);
        efx = _ &lt;: _, pf.flanger_mono(10,fldel,1,fb,0) : dry_wet(fldw);
    };

// Pannoramique:
panno = _ : sp.panner(hslider (&quot;pan[midi:ctrl 10]&quot;,0.5,0,1,0.001)) : _,_;

// REVERB (from freeverb_demo)
reverb = _,_ &lt;: (*(g)*fixedgain,*(g)*fixedgain :
    re.stereo_freeverb(combfeed, allpassfeed, damping, spatSpread)),
    *(1-g), *(1-g) :&gt; _,_
    with {
        scaleroom   = 0.28;
        offsetroom  = 0.7;
        allpassfeed = 0.5;
        scaledamp   = 0.4;
        fixedgain   = 0.1;
        origSR = 44100;

        damping = vslider(&quot;Damp[midi:ctrl 95]&quot;,0.5, 0, 1, 0.025)*scaledamp*origSR/ma.SR;
        combfeed = vslider(&quot;RoomSize[midi:ctrl 12]&quot;, 0.7, 0, 1, 0.025)*scaleroom*origSR/ma.SR + offsetroom;
        spatSpread = vslider(&quot;Stereo[midi:ctrl 90]&quot;,0.6,0,1,0.01)*46*ma.SR/origSR;
        g = vslider(&quot;dryWetReverb[midi:ctrl 91]&quot;, 0.4, 0, 1, 0.001);
        // (g = Dry/Wet)
    };

// Dry-Wet (from C. LEBRETON)
dry_wet(dw,x,y) = wet*y + dry*x
    with {
        wet = 0.5*(dw+1.0);
        dry = 1.0-wet;
    };

// ALL
effect = _ *(volFX) : ef.cubicnl_nodc(drive, 0.1) : flanger : panno : reverb;

process = wfosc(gFreq) * vol;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust27/exfaust27.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="delayecho">delayEcho</h1>
<h2 id="echo">echo</h2>
<div class="faust-run"><a href="img/src/exfaust28/exfaust28-svg/process.svg" target="_blank"><img src="img/src/exfaust28/exfaust28-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check misceffects.lib
// for more accurate examples of echo functions

declare name        &quot;echo&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;
//-----------------------------------------------
//              A Simple Echo
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

process = vgroup(&quot;echo-simple&quot;, ef.echo1s);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust28/exfaust28.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="quadecho">quadEcho</h2>
<div class="faust-run"><a href="img/src/exfaust29/exfaust29-svg/process.svg" target="_blank"><img src="img/src/exfaust29/exfaust29-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check misceffects.lib
// for more accurate examples of echo functions

declare name        &quot;quadEcho&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2007&quot;;

//-----------------------------------------------
//              A 1 second quadriphonic Echo
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

process = vgroup(&quot;stereo echo&quot;, multi(ef.echo1s, 4))
    with{ 
        multi(f,1) = f;
        multi(f,n) = f,multi(f,n-1);
    };                          
    </code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust29/exfaust29.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="smoothdelay">smoothDelay</h2>
<div class="faust-run"><a href="img/src/exfaust30/exfaust30-svg/process.svg" target="_blank"><img src="img/src/exfaust30/exfaust30-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name    &quot;smoothDelay&quot;;
declare author  &quot;Yann Orlarey&quot;;
declare copyright &quot;Grame&quot;;
declare version &quot;1.0&quot;;
declare license &quot;STK-4.3&quot;;

//--------------------------process----------------------------
//
//  A stereo smooth delay with a feedback control
//  
//  This example shows how to use sdelay, a delay that doesn&#39;t
//  click and doesn&#39;t transpose when the delay time is changed
//-------------------------------------------------------------

import(&quot;stdfaust.lib&quot;);

process = par(i, 2, voice)
    with 
    { 
        voice   = (+ : de.sdelay(N, interp, dtime)) ~ *(fback);
        N       = int(2^19); 
        interp  = hslider(&quot;interpolation[unit:ms][style:knob]&quot;,10,1,100,0.1)*ma.SR/1000.0; 
        dtime   = hslider(&quot;delay[unit:ms][style:knob]&quot;, 0, 0, 5000, 0.1)*ma.SR/1000.0;
        fback   = hslider(&quot;feedback[style:knob]&quot;,0,0,100,0.1)/100.0; 
    };</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust30/exfaust30.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="stereoecho">stereoEcho</h2>
<div class="faust-run"><a href="img/src/exfaust31/exfaust31-svg/process.svg" target="_blank"><img src="img/src/exfaust31/exfaust31-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check misceffects.lib
// for more accurate examples of echo functions

declare name        &quot;stereoEcho&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2007&quot;;

//-----------------------------------------------
//              A 1 second Stereo Echo
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

process = vgroup(&quot;stereo echo&quot;, (ef.echo1s, ef.echo1s));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust31/exfaust31.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="tapiir">tapiir</h2>
<div class="faust-run"><a href="img/src/exfaust32/exfaust32-svg/process.svg" target="_blank"><img src="img/src/exfaust32/exfaust32-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;tapiir&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//======================================================
//
//                  TAPIIR
//    (from Maarten de Boer&#39;s Tapiir)
//
//======================================================

import(&quot;stdfaust.lib&quot;);

dsize       = 524288;

// user interface
//---------------
tap(n)      = vslider(&quot;tap %n&quot;, 0,0,1,0.1);
in(n)       = vslider(&quot;input %n&quot;, 1,0,1,0.1);
gain        = vslider(&quot;gain&quot;, 1,0,1,0.1);
del         = vslider(&quot;delay (sec)&quot;, 0, 0, 5, 0.01) * ma.SR;

// mixer and matrix
//-----------------------------------------------------------
mixer(taps,lines)   =   par(i,taps,*(tap(i))),
                        par(i,lines,*(in(i)))
                        :&gt;  *(gain);

matrix(taps,lines)  = ( si.bus(lines+taps)
                        &lt;: tgroup(&quot;&quot;,
                                par(i, taps,
                                    hgroup(&quot;Tap %i&quot;,
                                        mixer(taps,lines) : de.delay(dsize,del))))
                      ) ~ si.bus(taps);

// tapiir
//--------
tapiir(taps,lines)  =   vgroup(&quot;Tapiir&quot;,
                            si.bus(lines)
                            &lt;: (matrix(taps,lines), si.bus(lines))
                            &lt;: vgroup( &quot;outputs&quot;, par( i, lines, hgroup(&quot;output %i&quot;, mixer(taps,lines)) ) )
                        );

process             =  tapiir(6,2);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust32/exfaust32.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="dynamic">dynamic</h1>
<h2 id="compressor">compressor</h2>
<div class="faust-run"><a href="img/src/exfaust33/exfaust33-svg/process.svg" target="_blank"><img src="img/src/exfaust33/exfaust33-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;compressor&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Compressor demo application&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.compressor_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust33/exfaust33.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="distortion">distortion</h2>
<div class="faust-run"><a href="img/src/exfaust34/exfaust34-svg/process.svg" target="_blank"><img src="img/src/exfaust34/exfaust34-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;distortion&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Distortion demo application.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.cubicnl_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust34/exfaust34.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="gatecompressor">gateCompressor</h2>
<div class="faust-run"><a href="img/src/exfaust35/exfaust35-svg/process.svg" target="_blank"><img src="img/src/exfaust35/exfaust35-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;gateCompressor&quot;;

import(&quot;stdfaust.lib&quot;);

process = 
// ol.sawtooth_demo &lt;: 
//      el.gate_demo : ef.compressor_demo :&gt; fi.spectral_level_demo &lt;: _,_;
   vgroup(&quot;[1]&quot;, dm.sawtooth_demo) &lt;:
   vgroup(&quot;[2]&quot;, dm.gate_demo) : 
   vgroup(&quot;[3]&quot;, dm.compressor_demo) :&gt;
   vgroup(&quot;[4]&quot;, dm.spectral_level_demo) &lt;:
    _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust35/exfaust35.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="noisegate">noiseGate</h2>
<div class="faust-run"><a href="img/src/exfaust36/exfaust36-svg/process.svg" target="_blank"><img src="img/src/exfaust36/exfaust36-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;noiseGate&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Gate demo application.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.gate_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust36/exfaust36.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="volume">volume</h2>
<div class="faust-run"><a href="img/src/exfaust37/exfaust37-svg/process.svg" target="_blank"><img src="img/src/exfaust37/exfaust37-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;volume&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-----------------------------------------------
//          Volume control in dB
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

gain        = vslider(&quot;[1]&quot;, 0, -70, +4, 0.1) : ba.db2linear : si.smoo;

process     = *(gain);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust37/exfaust37.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="filtering">filtering</h1>
<h2 id="apf">APF</h2>
<div class="faust-run"><a href="img/src/exfaust38/exfaust38-svg/process.svg" target="_blank"><img src="img/src/exfaust38/exfaust38-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;APF&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = APF(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust38/exfaust38.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="bandfilter">bandFilter</h2>
<div class="faust-run"><a href="img/src/exfaust39/exfaust39-svg/process.svg" target="_blank"><img src="img/src/exfaust39/exfaust39-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name        &quot;bandFilter&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

import(&quot;stdfaust.lib&quot;);

//---------------------second order filter--------------------------
// filter(Q,F,G)
//              Q : quality factor [1..100]
//              F : frequency (Hz)
//              G : gain [0..1]
//------------------------------------------------------------------

filter(Q,F,G)   = fi.TF2(  (1 +  K/Q + K*K)     / D,
                         2 * (K*K - 1)      / D,
                        (1 - K/Q + K*K)     / D,
                         2 * (K*K - 1)      / D,
                        (1 - V*K/Q + K*K)   / D
                     )
        with {
                V = ba.db2linear(G);
                K = tan(ma.PI*F/ma.SR);
                D = 1 + V*K/Q + K*K;
        };

//--------------- Band Filter with user interface ------------------
// bandfilter(F)
//              F : default frequency (Hz)
//
//------------------------------------------------------------------

bandfilter(F)   = filter(   nentry(&quot;Q factor [style:knob]&quot;,50,0.1,100,0.1),
                            nentry(&quot;freq [unit:Hz][style:knob]&quot;, F, 20, 20000, 1),
                            0 - vslider(&quot;gain [unit:dB]&quot;, 0, -50, 50, 0.1)
                        );

//------------------------- Process --------------------------------

process         = vgroup(&quot;Bandfilter&quot;, bandfilter(1000));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust39/exfaust39.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="bpf">BPF</h2>
<div class="faust-run"><a href="img/src/exfaust40/exfaust40-svg/process.svg" target="_blank"><img src="img/src/exfaust40/exfaust40-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;BPF&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = BPF(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust40/exfaust40.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="crybaby">cryBaby</h2>
<div class="faust-run"><a href="img/src/exfaust41/exfaust41-svg/process.svg" target="_blank"><img src="img/src/exfaust41/exfaust41-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;cryBaby&quot;;
declare description &quot;Application demonstrating the CryBaby wah pedal emulation&quot;;
import(&quot;stdfaust.lib&quot;);
process = dm.crybaby_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust41/exfaust41.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="dnn">DNN</h2>
<div class="faust-run"><a href="img/src/exfaust42/exfaust42-svg/process.svg" target="_blank"><img src="img/src/exfaust42/exfaust42-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// Forward Deep Neural Net (DNN), any number of layers of any size each

declare name    &quot;DNN&quot;;
declare author  &quot;JOS&quot;;
declare license &quot;STK-4.3&quot;;

import(&quot;stdfaust.lib&quot;);

layerSizes = (8,5,8); // autoencoder with 8 in &amp; out, 5-state hidden layer
w(m,n,k) = m*100+n*10+k; // placeholder weights: m=layer, n=fromNode, k=destNode

M = ba.count(layerSizes);
N(l) = ba.take(l+1,layerSizes); // Nodes per layer

process = seq(m, M-1, layer(m))
// look at weights:
// process = par(m,M,par(n,N(m),par(k,N(m),w(m,n,k))))
with {
  layer(m) = weights(m) :&gt; nonlinearities(m);
  nonlinearities(m) = bus(N(m)*N(m+1)) :&gt; par(n,N(m+1),nl(n));
  weights(m) = bus(N(m)) &lt;: par(n,N(m),(bus(N(m+1))&lt;:wts(m,n)));
  wts(m,n) = bus(N(m+1)) : par(k,N(m+1),*(w(m,n,k)));
  nl(n,x) = x * (x&gt;0); // ReLU
  bus(N) = par(k,N,_);
};</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust42/exfaust42.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="filterbank">filterBank</h2>
<div class="faust-run"><a href="img/src/exfaust43/exfaust43-svg/process.svg" target="_blank"><img src="img/src/exfaust43/exfaust43-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;filterBank&quot;;
declare description &quot;Graphic Equalizer consisting of a filter-bank driving a bank of faders&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.filterbank_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust43/exfaust43.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="graphiceqlab">graphicEqLab</h2>
<div class="faust-run"><a href="img/src/exfaust44/exfaust44-svg/process.svg" target="_blank"><img src="img/src/exfaust44/exfaust44-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;graphicEqLab&quot;;
declare description &quot;Signal generators through a filter bank with spectrum analysis display&quot;;

import(&quot;stdfaust.lib&quot;);

process = 
// ol.sawtooth_demo : fl.filterbank_demo : fl.spectral_level_demo &lt;: _,_;
 vgroup(&quot;[1]&quot;,dm.sawtooth_demo) : 
 vgroup(&quot;[2]&quot;,dm.filterbank_demo) : 
 vgroup(&quot;[3]&quot;,dm.spectral_level_demo) &lt;:
  _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust44/exfaust44.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="highshelf">highShelf</h2>
<div class="faust-run"><a href="img/src/exfaust45/exfaust45-svg/process.svg" target="_blank"><img src="img/src/exfaust45/exfaust45-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;highShelf&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = highShelf(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust45/exfaust45.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="hpf">HPF</h2>
<div class="faust-run"><a href="img/src/exfaust46/exfaust46-svg/process.svg" target="_blank"><img src="img/src/exfaust46/exfaust46-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;HPF&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = HPF(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust46/exfaust46.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="lfboost">lfBoost</h2>
<div class="faust-run"><a href="img/src/exfaust47/exfaust47-svg/process.svg" target="_blank"><img src="img/src/exfaust47/exfaust47-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name        &quot;lfboost&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//------------------------------------------------------------------
//  DAFX, Digital Audio Effects (Wiley ed.)
//  chapter 2   : filters
//  section 2.3 : Equalizers
//  page 53     : second order shelving filter design
//------------------------------------------------------------------

import(&quot;stdfaust.lib&quot;);

//----------------------low frequency boost filter -------------------------------
// lfboost(F,G)
//              F : frequency (in Hz)
//              G : gain (in dB)
//
//--------------------------------------------------------------------------------

lfboost(F,G)    = fi.TF2((1 + sqrt(2*V)*K + V*K*K) / denom,
                        2 * (V*K*K - 1) / denom,
                        (1 - sqrt(2*V)*K + V*K*K) / denom,
                        2 * (K*K - 1) / denom,
                        (1 - sqrt(2)*K + K*K) / denom)
        with {
            V           = ba.db2linear(G);
            K           = tan(ma.PI*F/ma.SR);
            denom       = 1 + sqrt(2)*K + K*K;
        };

//====================low frequency boost process ===============================

process = vgroup(&quot;lowboost&quot;, lfboost(nentry(&quot;freq [unit:Hz][style:knob]&quot;, 100, 20, 150, 1),
                                    vslider(&quot;gain [unit:dB]&quot;, 0, -20, 20, 0.1)));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust47/exfaust47.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="lowboost">lowBoost</h2>
<div class="faust-run"><a href="img/src/exfaust48/exfaust48-svg/process.svg" target="_blank"><img src="img/src/exfaust48/exfaust48-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name        &quot;lowboost&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//------------------------------------------------------------------
//  DAFX, Digital Audio Effects (Wiley ed.)
//  chapter 2   : filters
//  section 2.3 : Equalizers
//  page 53     : second order shelving filter design
//------------------------------------------------------------------

import(&quot;stdfaust.lib&quot;);

//------------------- low-frequency shelving boost (table 2.3) --------------------

V0(g)           = pow(10,g/20.0);
K(fc)           = tan(ma.PI*fc/ma.SR);
square(x)       = x*x;
denom(fc)       = 1 + sqrt(2)*K(fc) + square(K(fc));

lfboost(fc, g)  = fi.TF2((1 + sqrt(2*V0(g))*K(fc) + V0(g)*square(K(fc))) / denom(fc),
                        2 * (V0(g)*square(K(fc)) - 1) / denom(fc),
                        (1 - sqrt(2*V0(g))*K(fc) + V0(g)*square(K(fc))) / denom(fc),
                        2 * (square(K(fc)) - 1) / denom(fc),
                        (1 - sqrt(2)*K(fc) + square(K(fc))) / denom(fc));

//------------------------------ User Interface -----------------------------------

freq                = hslider(&quot;[1]freq [unit:Hz][style:knob]&quot;, 1000, 20, 20000, 0.1);
gain                = hslider(&quot;[2]gain [unit:dB][style:knob]&quot;, 0, -20, 20, 0.1);

//----------------------------------- Process -------------------------------------

process             = vgroup(&quot;low-freq shelving boost&quot;, lfboost(freq,gain));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust48/exfaust48.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="lowcut">lowCut</h2>
<div class="faust-run"><a href="img/src/exfaust49/exfaust49-svg/process.svg" target="_blank"><img src="img/src/exfaust49/exfaust49-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name        &quot;lowcut&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//------------------------------------------------------------------
//  DAFX, Digital Audio Effects (Wiley ed.)
//  chapter 2   : filters
//  section 2.3 : Equalizers
//  page 53     : second order shelving filter design
//------------------------------------------------------------------

import(&quot;stdfaust.lib&quot;);

//------------------- low-frequency shelving cut (table 2.3) --------------------

V0(g)           = pow(10,g/-20.0);
K(fc)           = tan(ma.PI*fc/ma.SR);
squ(x)      = x*x;
denom(fc,g)     = 1 + sqrt(2*V0(g))*K(fc) + V0(g)*squ(K(fc));

lfcut(fc, g)    = fi.TF2((1 + sqrt(2)*K(fc) + squ(K(fc))) / denom(fc,g),
                        2 * (squ(K(fc)) - 1) / denom(fc,g),
                        (1 - sqrt(2)*K(fc) + squ(K(fc))) / denom(fc,g),
                        2 * (V0(g)*squ(K(fc)) - 1) / denom(fc,g),
                        (1 - sqrt(2*V0(g))*K(fc) + V0(g)*squ(K(fc))) / denom(fc,g));

//------------------------------ User Interface -----------------------------------

freq            = hslider(&quot;freq [unit:Hz][style:knob]&quot;, 100, 20, 5000, 1);
att             = hslider(&quot;attenuation [unit:dB][style:knob]&quot;, 0, -96, 10, 0.1);

//----------------------------------- Process -------------------------------------

process         = vgroup(&quot;low-freq shelving cut&quot;, lfcut(freq,att));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust49/exfaust49.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="lowshelf">lowShelf</h2>
<div class="faust-run"><a href="img/src/exfaust50/exfaust50-svg/process.svg" target="_blank"><img src="img/src/exfaust50/exfaust50-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;lowShelf&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = lowShelf(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust50/exfaust50.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="lpf">LPF</h2>
<div class="faust-run"><a href="img/src/exfaust51/exfaust51-svg/process.svg" target="_blank"><img src="img/src/exfaust51/exfaust51-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;LPF&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = LPF(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust51/exfaust51.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="moogvcf">moogVCF</h2>
<div class="faust-run"><a href="img/src/exfaust52/exfaust52-svg/process.svg" target="_blank"><img src="img/src/exfaust52/exfaust52-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;moogVCF&quot;;
declare description &quot;Exercise and compare three Moog VCF implementations&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.moog_vcf_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust52/exfaust52.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="notch">notch</h2>
<div class="faust-run"><a href="img/src/exfaust53/exfaust53-svg/process.svg" target="_blank"><img src="img/src/exfaust53/exfaust53-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;notch&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = notch(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust53/exfaust53.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="parametriceqlab">parametricEqLab</h2>
<div class="faust-run"><a href="img/src/exfaust54/exfaust54-svg/process.svg" target="_blank"><img src="img/src/exfaust54/exfaust54-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;parametricEqLab&quot;;
declare description &quot;Demonstrate the Parametric Equalizer sections on test signals with spectrum analysis display&quot;;

import(&quot;stdfaust.lib&quot;);

//process = ol.sawtooth_demo : fl.parametric_eq_demo :
//          fl.mth_octave_spectral_level_demo(2) &lt;: _,_;
process =
  vgroup(&quot;[1]&quot;, dm.sawtooth_demo) :
  vgroup(&quot;[2]&quot;, dm.parametric_eq_demo) :
  vgroup(&quot;[3]&quot;, dm.mth_octave_spectral_level_demo(2))
  &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust54/exfaust54.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="parametricequalizer">parametricEqualizer</h2>
<div class="faust-run"><a href="img/src/exfaust55/exfaust55-svg/process.svg" target="_blank"><img src="img/src/exfaust55/exfaust55-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;parametricEqualizer&quot;;
declare description &quot;Exercise and compare Parametric Equalizer sections on test signals&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.parametric_eq_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust55/exfaust55.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="peakingeq">peakingEQ</h2>
<div class="faust-run"><a href="img/src/exfaust56/exfaust56-svg/process.svg" target="_blank"><img src="img/src/exfaust56/exfaust56-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;peakingEQ&quot;;

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit:dB]&quot;, 0, -10, 10, 0.1);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = peakingEQ(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust56/exfaust56.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="peaknotch">peakNotch</h2>
<div class="faust-run"><a href="img/src/exfaust57/exfaust57-svg/process.svg" target="_blank"><img src="img/src/exfaust57/exfaust57-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check filters.lib
// for more accurate examples of filter functions

declare name &quot;peakNotch&quot;; 

import(&quot;maxmsp.lib&quot;);

G = hslider(&quot;Gain [unit: lin]&quot;, 1, 0, 8, 0.01);
F = hslider(&quot;Freq&quot;, 1000, 100, 10000, 1);
Q = hslider(&quot;Q&quot;, 1, 0.01, 100, 0.01);

process(x) = peakNotch(x,F,G,Q);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust57/exfaust57.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="spectraltilt">spectralTilt</h2>
<div class="faust-run"><a href="img/src/exfaust58/exfaust58-svg/process.svg" target="_blank"><img src="img/src/exfaust58/exfaust58-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;spectralTilt&quot;;
declare description &quot;Demonstrate the Spectral Tilt effect on test signals&quot;;

import(&quot;stdfaust.lib&quot;);

O = 2; // filter order

process = dm.spectral_tilt_demo(2);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust58/exfaust58.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vcfwahlab">vcfWahLab</h2>
<div class="faust-run"><a href="img/src/exfaust59/exfaust59-svg/process.svg" target="_blank"><img src="img/src/exfaust59/exfaust59-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>import(&quot;stdfaust.lib&quot;);
declare description &quot;Demonstrate competing variable-lowpass-filter effects on test signals with spectrum analysis display&quot;;

declare name &quot;vcfWahLab&quot;;

// process = ol.sawtooth_demo : 
//    el.crybaby_demo : el.moog_vcf_demo : el.wah4_demo : 
//    fl.spectral_level_demo &lt;: _,_;
process = 
 vgroup(&quot;[1]&quot;, dm.sawtooth_demo) : 
 vgroup(&quot;[2]&quot;, dm.crybaby_demo) : 
 vgroup(&quot;[3]&quot;, dm.wah4_demo) : 
 vgroup(&quot;[4]&quot;, dm.moog_vcf_demo) : 
 vgroup(&quot;[5]&quot;, dm.spectral_level_demo) &lt;:
  _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust59/exfaust59.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vocoder">vocoder</h2>
<div class="faust-run"><a href="img/src/exfaust60/exfaust60-svg/process.svg" target="_blank"><img src="img/src/exfaust60/exfaust60-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Vocoder&quot;;
declare version &quot;0.0&quot;;
declare author &quot;RM&quot;;
declare description &quot;Use example of the vocoder function where an impulse train is used as excitation.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.vocoder_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust60/exfaust60.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="wahpedal">wahPedal</h2>
<div class="faust-run"><a href="img/src/exfaust61/exfaust61-svg/process.svg" target="_blank"><img src="img/src/exfaust61/exfaust61-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;wahPedal&quot;;
declare description &quot;Demonstrate the Fourth-Order Wah pedal (similar to the Moog VCF)&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.wah4_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust61/exfaust61.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="gameaudio">gameaudio</h1>
<h2 id="bubble">bubble</h2>
<div class="faust-run"><a href="img/src/exfaust62/exfaust62-svg/process.svg" target="_blank"><img src="img/src/exfaust62/exfaust62-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;bubble&quot;;
declare description &quot;Production of a water drop bubble sound.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c) 2017: Yann Orlarey, GRAME&quot;;

import(&quot;stdfaust.lib&quot;);


//---------------------------`bubble`--------------------------
// bubble(f0, trig) : produces a water drop bubble sound
//
// #### Usage
//
// ```
// bubble(f0, trig) : _
// ```
//
// Where:
//
// * ` f0 `: base frequency of bubble sound
// * `trig`: trigs the bubble sound on the rising front
//
// #### Example
//
// ```
// button(&quot;drop&quot;) : bubble(600) : _
// ```
//
// #### Reference:
//
// &lt;http://www.cs.ubc.ca/~kvdoel/publications/tap05.pdf&gt;
//------------------------------------------------------------

bubble(f0,trig) = os.osc(f) * (exp(-damp*time) : si.smooth(0.99))
    with {
        damp = 0.043*f0 + 0.0014*f0^(3/2);
        f = f0*(1+sigma*time);
        sigma = eta * damp;
        eta = 0.075;
        time = 0 : (select2(trig&gt;trig&#39;):+(1)) ~ _ : ba.samp2sec;
    };

process = button(&quot;drop&quot;) : bubble(hslider(&quot;v:bubble/freq&quot;, 600, 150, 2000, 1)) &lt;: dm.freeverb_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust62/exfaust62.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="rain">rain</h2>
<div class="faust-run"><a href="img/src/exfaust63/exfaust63-svg/process.svg" target="_blank"><img src="img/src/exfaust63/exfaust63-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//----------------------`rain`--------------------------
// A very simple rain simulator
//
// #### Usage
//
// ```
//  rain(d,l) : _,_
// ```
//
// Where:
//
// * `d`: is the density of the rain: between 0 and 1
// * `l`: is the level (volume) of the rain: between 0 and 1
//
//----------------------------------------------------------

import(&quot;stdfaust.lib&quot;);

rain(density,level) = no.multinoise(2) : par(i, 2, drop) : par(i, 2, *(level))
    with {
        drop = _ &lt;: @(1), (abs &lt; density) : *;
    };

process  =  rain (
                hslider(&quot;v:rain/density&quot;, 300, 0, 1000, 1) / 1000,
                hslider(&quot;v:rain/volume&quot;, 0.5, 0, 1, 0.01)
            );</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust63/exfaust63.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="wind">wind</h2>
<div class="faust-run"><a href="img/src/exfaust64/exfaust64-svg/process.svg" target="_blank"><img src="img/src/exfaust64/exfaust64-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//----------------------`wind`--------------------------
// A very simple wind simulator, based on a filtered white noise
//
// #### Usage
//
// ```
//  wind(f) : _
// ```
//
// Where:
//
// * `f`: is the force of the wind: between 0 and 1
//
//----------------------------------------------------------

import(&quot;stdfaust.lib&quot;);

wind(force) = no.multinoise(2) : par(i, 2, ve.moog_vcf_2bn(force,freq)) : par(i, 2, *(force))
    with {
        freq = (force*87)+1 : ba.pianokey2hz;
    };

process = wind ( hslider(&quot;v:wind/force&quot;,0.66,0,1,0.01) : si.smooth (0.997) );</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust64/exfaust64.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="generator">generator</h1>
<h2 id="filterosc">filterOsc</h2>
<div class="faust-run"><a href="img/src/exfaust65/exfaust65-svg/process.svg" target="_blank"><img src="img/src/exfaust65/exfaust65-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;filterOSC&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Simple application demoing filter based oscillators.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.oscrs_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust65/exfaust65.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="noise">noise</h2>
<div class="faust-run"><a href="img/src/exfaust66/exfaust66-svg/process.svg" target="_blank"><img src="img/src/exfaust66/exfaust66-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check noises.lib
// for more accurate examples of noise functions

declare name        &quot;Noise&quot;;
declare version     &quot;1.1&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2009&quot;;

//-----------------------------------------------------------------
// Noise generator and demo file for the Faust math documentation
//-----------------------------------------------------------------

&lt;mdoc&gt;
\section{Presentation of the &quot;noise.dsp&quot; Faust program}
This program describes a white noise generator with an interactive volume, using a random function.

\subsection{The random function}
The \texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers.
&lt;equation&gt;random&lt;/equation&gt;

\subsection{The noise function}
The white noise then corresponds to:
&lt;equation&gt;noise&lt;/equation&gt;
&lt;/mdoc&gt;

random  = +(12345)~*(1103515245);
noise   = random/2147483647.0;

&lt;mdoc&gt;
\subsection{Just add a user interface element to play volume!}
Endly, the sound level of this program is controlled by a user slider, which gives the following equation: 
&lt;equation&gt;process&lt;/equation&gt;
&lt;/mdoc&gt;

&lt;mdoc&gt;
\section{Block-diagram schema of process}
This process is illustrated on figure 1.
&lt;diagram&gt;process&lt;/diagram&gt;
&lt;/mdoc&gt;

process = noise * vslider(&quot;Volume[style:knob][acc: 0 0 -10 0 10]&quot;, 0.5, 0, 1, 0.1);

&lt;mdoc&gt;
\section{Notice of this documentation}
You might be careful of certain information and naming conventions used in this documentation:
&lt;notice/&gt;

\section{Listing of the input code}
The following listing shows the input Faust code, parsed to compile this mathematical documentation.
&lt;listing/&gt;
&lt;/mdoc&gt;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust66/exfaust66.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="noisemetadata">noiseMetadata</h2>
<div class="faust-run"><a href="img/src/exfaust67/exfaust67-svg/process.svg" target="_blank"><img src="img/src/exfaust67/exfaust67-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: This a &quot;legacy example based on a deprecated library&quot;. Check noises.lib
// for more accurate examples of noise functions

&lt;mdoc&gt;
\title{&lt;metadata&gt;name&lt;/metadata&gt;}
\author{&lt;metadata&gt;author&lt;/metadata&gt;}
\date{\today}
\maketitle

\begin{tabular}{ll}
    \hline
    \textbf{name}       &amp; &lt;metadata&gt;name&lt;/metadata&gt; \\
    \textbf{version}    &amp; &lt;metadata&gt;version&lt;/metadata&gt; \\
    \textbf{author}     &amp; &lt;metadata&gt;author&lt;/metadata&gt; \\
    \textbf{license}    &amp; &lt;metadata&gt;license&lt;/metadata&gt; \\
    \textbf{copyright}  &amp; &lt;metadata&gt;copyright&lt;/metadata&gt; \\
    \hline
\end{tabular}
\bigskip
&lt;/mdoc&gt;
//-----------------------------------------------------------------
// Noise generator and demo file for the Faust math documentation
//-----------------------------------------------------------------

declare name        &quot;noiseMetadata&quot;; // avoid same name as in noise.dsp
declare version     &quot;1.1&quot;;
declare author      &quot;Grame&quot;;
declare author      &quot;Yghe&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2009&quot;;

&lt;mdoc&gt;
\section{Presentation of the &quot;noise.dsp&quot; Faust program}
This program describes a white noise generator with an interactive volume, using a random function.

\subsection{The random function}
&lt;/mdoc&gt;

random  = +(12345)~*(1103515245);

&lt;mdoc&gt;
The \texttt{random} function describes a generator of random numbers, which equation follows. You should notice hereby the use of an integer arithmetic on 32 bits, relying on integer wrapping for big numbers.
&lt;equation&gt;random&lt;/equation&gt;

\subsection{The noise function}
&lt;/mdoc&gt;

noise   = random/2147483647.0;

&lt;mdoc&gt;
The white noise then corresponds to:
&lt;equation&gt;noise&lt;/equation&gt;

\subsection{Just add a user interface element to play volume!}
&lt;/mdoc&gt;

process = noise * vslider(&quot;Volume[style:knob]&quot;, 0, 0, 1, 0.1);

&lt;mdoc&gt;
Endly, the sound level of this program is controlled by a user slider, which gives the following equation: 
&lt;equation&gt;process&lt;/equation&gt;

\section{Block-diagram schema of process}
This process is illustrated on figure 1.
&lt;diagram&gt;process&lt;/diagram&gt;

\section{Notice of this documentation}
You might be careful of certain information and naming conventions used in this documentation:
&lt;notice /&gt;

\section{Listing of the input code}
The following listing shows the input Faust code, parsed to compile this mathematical documentation.
&lt;listing mdoctags=&quot;false&quot; dependencies=&quot;false&quot; distributed=&quot;false&quot; /&gt;
&lt;/mdoc&gt;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust67/exfaust67.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="osc">osc</h2>
<div class="faust-run"><a href="img/src/exfaust68/exfaust68-svg/process.svg" target="_blank"><img src="img/src/exfaust68/exfaust68-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;osc&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2009&quot;;

//-----------------------------------------------
//          Sinusoidal Oscillator
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

vol             = hslider(&quot;volume [unit:dB]&quot;, 0, -96, 0, 0.1) : ba.db2linear : si.smoo ;
freq            = hslider(&quot;freq [unit:Hz]&quot;, 1000, 20, 24000, 1);

process         = vgroup(&quot;Oscillator&quot;, os.osc(freq) * vol);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust68/exfaust68.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="osci">osci</h2>
<div class="faust-run"><a href="img/src/exfaust69/exfaust69-svg/process.svg" target="_blank"><img src="img/src/exfaust69/exfaust69-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;osci&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2009&quot;;

//-----------------------------------------------
//          Sinusoidal Oscillator
//      (with linear interpolation)
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

vol             = hslider(&quot;volume [unit:dB]&quot;, 0, -96, 0, 0.1) : ba.db2linear : si.smoo ;
freq            = hslider(&quot;freq [unit:Hz]&quot;, 1000, 20, 24000, 1);

process         = vgroup(&quot;Oscillator&quot;, os.osci(freq) * vol);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust69/exfaust69.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="sawtoothlab">sawtoothLab</h2>
<div class="faust-run"><a href="img/src/exfaust70/exfaust70-svg/process.svg" target="_blank"><img src="img/src/exfaust70/exfaust70-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;sawtoothLab&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;An application demonstrating the different sawtooth oscillators of Faust.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.sawtooth_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust70/exfaust70.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="virtualanalog">virtualAnalog</h2>
<div class="faust-run"><a href="img/src/exfaust71/exfaust71-svg/process.svg" target="_blank"><img src="img/src/exfaust71/exfaust71-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;VirtualAnalog&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Virtual analog oscillator demo application.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.virtual_analog_oscillator_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust71/exfaust71.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="virtualanaloglab">virtualAnalogLab</h2>
<div class="faust-run"><a href="img/src/exfaust72/exfaust72-svg/process.svg" target="_blank"><img src="img/src/exfaust72/exfaust72-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;virtualAnalogLab&quot;;

import(&quot;stdfaust.lib&quot;);

process = 
 vgroup(&quot;[1]&quot;, dm.virtual_analog_oscillator_demo) : 
 vgroup(&quot;[2]&quot;, dm.moog_vcf_demo) : 
 vgroup(&quot;[3]&quot;, dm.spectral_level_demo)
 // See also: vgroup(&quot;[3]&quot;, dm.fft_spectral_level_demo(32))
  &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust72/exfaust72.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="misc">misc</h1>
<h2 id="capture">capture</h2>
<div class="faust-run"><a href="img/src/exfaust73/exfaust73-svg/process.svg" target="_blank"><img src="img/src/exfaust73/exfaust73-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;capture&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-------------------------------------------------
//      Capture : record up to 8s of sound and
//      playback the recorded sound in loop
//-------------------------------------------------

import(&quot;stdfaust.lib&quot;);

B = button(&quot;Capture&quot;);  // Capture sound while pressed
I = int(B);             // convert button signal from float to integer
R = (I-I&#39;) &lt;= 0;        // Reset capture when button is pressed
D = (+(I):*(R))~_;      // Compute capture duration while button is pressed: 0..NNNN0..MMM


capture = *(B) : (+ : de.delay(8*65536, D-1)) ~ *(1.0-B) ;

level       = hslider(&quot;level (db)&quot;, 0, -96, 4, 0.1) : ba.db2linear : si.smoo;

process     = vgroup( &quot;Audio Capture&quot;, capture : *(level) ) ;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust73/exfaust73.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="matrix">matrix</h2>
<div class="faust-run"><a href="img/src/exfaust74/exfaust74-svg/process.svg" target="_blank"><img src="img/src/exfaust74/exfaust74-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;matrix&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-----------------------------------------------
// Audio Matrix : N inputs x M outputs
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

Fader(in)       = ba.db2linear(vslider(&quot;Input %in&quot;, -10, -96, 4, 0.1));
Mixer(N,out)    = hgroup(&quot;Output %out&quot;, par(in, N, *(Fader(in)) ) :&gt; _ );
Matrix(N,M)     = tgroup(&quot;Matrix %N x %M&quot;, par(in, N, _) &lt;: par(out, M, Mixer(N, out)));

process = Matrix(8, 8);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust74/exfaust74.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="miditester">midiTester</h2>
<div class="faust-run"><a href="img/src/exfaust75/exfaust75-svg/process.svg" target="_blank"><img src="img/src/exfaust75/exfaust75-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;midiTester&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Vincent Rateau, GRAME&quot;;
declare license     &quot;GPL v3&quot;;
declare reference   &quot;www.sonejo.net&quot;;

// FAUST MIDI TESTER

process = _*0, (vgroup(&quot;FAUST MIDI TESTER&quot;, hgroup(&quot;[1]&quot;, controltester, noteontester, noteofftester, midiclocktester), hgroup(&quot;[2]&quot;, kattester, pctester, chattester, pitchwheeltester) :&gt; _)) : attach;

///////////////////////////

//Ctrl tester (ctrl ): tester(midi in, midi out)
controltester = vgroup(&quot;CTRL IN/OUT&quot;, valuetest(50,51), booltest(100,101))
with{
valuetest(i,o) = hslider(&quot;Ctrl Value IN (Ctrl %i) [midi:ctrl %i]&quot;, 60, 0, 127, 1) : hbargraph(&quot;Ctrl Value OUT (Ctrl %o) [midi:ctrl %o]&quot;, 0, 127);
booltest(i,o) = checkbox(&quot;Ctrl Bool IN (Ctrl %i) [midi:ctrl %i]&quot;) : hbargraph(&quot;Ctrl Bool OUT (Ctrl %o) [midi:ctrl %o]&quot;, 0, 1);
};

//Note tester (keyon) : tester(midi in, midi out)
noteontester = vgroup(&quot;NOTE ON IN/OUT&quot;, valuetest(50,51), booltest(100,101))
with{
valuetest(i,o) = hslider(&quot;NoteOn Value IN (Note %i) [midi:keyon %i]&quot;, 60, 0, 127, 1) : hbargraph(&quot;NoteOn Value OUT (Note %o) [midi:keyon %o]&quot;, 0, 127);
booltest(i,o) = checkbox(&quot;NoteOn Bool IN (Note %i) [midi:keyon %i]&quot;) : hbargraph(&quot;NoteOn Bool OUT (Note %o) [midi:keyon %o]&quot;, 0, 1);
};

//Note tester (keyoff) : tester(midi in, midi out)
noteofftester = vgroup(&quot;NOTE OFF IN/OUT&quot;, valuetest(50,51), booltest(100,101))
with{
valuetest(i,o) = hslider(&quot;NoteOff Value IN (Note %i) [midi:keyoff %i]&quot;, 60, 0, 127, 1) : hbargraph(&quot;NoteOff Value OUT (Note %o) [midi:keyoff %o]&quot;, 0, 127);
booltest(i,o) = checkbox(&quot;NoteOff Bool IN (Note %i) [midi:keyoff %i]&quot;) : hbargraph(&quot;NoteOff Bool OUT (Note %o) [midi:keyoff %o]&quot;, 0, 1);
};

//Midisync tester
midiclocktester = vgroup(&quot;MIDI SYNC (IN)&quot;, clock, startstop)
with{
clock = checkbox(&quot;MIDI clock signal [midi:clock]&quot;);
startstop = checkbox(&quot;MIDI START/STOP [midi:start] [midi:stop]&quot;);
};

//Key Aftertouch tester (keypress) : tester(midi in, midi out)
kattester = vgroup(&quot;KEY AFTERTOUCH (KAT) IN/OUT&quot;,valuetest(50,51), booltest(100,101))
with{
valuetest(i,o) = hslider(&quot;Note KAT Value IN (Note %i) [midi:keypress %i]&quot;, 60, 0, 127, 1) : hbargraph(&quot;Note KAT Value OUT (Note %o) [midi:keypress %o]&quot;, 0, 127);
booltest(i,o) = checkbox(&quot;Note KAT Bool IN (Note %i) [midi:keypress %i]&quot;) : hbargraph(&quot;Note KAT Bool OUT (Note %o) [midi:keypress %o]&quot;, 0, 1);
};

//ProgramChange tester (pgm) : tester(midi in, midi out)
pctester = vgroup(&quot;PROGRAM CHANGE (PC) IN/OUT&quot;,valuetest(50,51), booltest(100,101))
with{
valuetest(i,o) = hslider(&quot;ProgramChange Value IN (PC %i) [midi:pgm %i]&quot;, 60, 0, 127, 1) : hbargraph(&quot;ProgramChange Value OUT (PC %o) [midi:pgm %o]&quot;, 0, 127);
booltest(i,o) = checkbox(&quot;ProgramChange Bool IN (PC %i) [midi:pgm %i]&quot;) : hbargraph(&quot;ProgramChange Bool OUT (PC %o) [midi:pgm %o]&quot;, 0, 1);
};

//Channel Aftertourch tester (chanpress) : tester(midi in, midi out)
chattester = vgroup(&quot;CHANNEL AFTERTOUCH (CHAT) IN/OUT&quot;,valuetest(50,51), booltest(100,101))
with{
valuetest(i,o) = hslider(&quot;Note CHAT Value IN (Note %i) [midi:chanpress %i]&quot;, 60, 0, 127, 1) : hbargraph(&quot;Note CHAT Value OUT (Note %o) [midi:chanpress %o]&quot;, 0, 127);
booltest(i,o) = checkbox(&quot;Note CHAT Bool IN (Note %i) [midi:chanpress %i]&quot;) : hbargraph(&quot;Note CHAT Bool OUT (Note %o) [midi:chanpress %o]&quot;, 0, 1);
};

//Pitchwheel tester (pitchwheel) : tester(midi in, midi out)
pitchwheeltester = vgroup(&quot;PITCHWHEEL IN/OUT&quot;,valuetest, booltest)
with{
valuetest = hslider(&quot;Pitchwheel Value IN  [midi:pitchwheel]&quot;, 0, -8192, 8191, 1) : hbargraph(&quot;Pitchwheel Value OUT[midi:pitchwheel]&quot;, -8192, 8191);
booltest = checkbox(&quot;Pitchwheel Bool IN [midi:pitchwheel]&quot;) : hbargraph(&quot;Pitchwheel Bool OUT [midi:pitchwheel]&quot;, 0, 1);
};</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust75/exfaust75.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="switcher">switcher</h2>
<div class="faust-run"><a href="img/src/exfaust76/exfaust76-svg/process.svg" target="_blank"><img src="img/src/exfaust76/exfaust76-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;switcher&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2007&quot;;

//-----------------------------------------------
// Switch between two stereo sources. 
// Useful to compare these two sources
// The parameter c\in{0,1} indicates the 
// channels to select
//-----------------------------------------------

switch(c,x0,x1,y0,y1) = sel(c,x0,y0), sel(c,x1,y1)
                            with { 
                                sel(c,x,y) = (1-c)*x + c*y; 
                            };
    
process = switch(hslider(&quot;source 0 &lt;-&gt; source 1&quot;,0,0,1,1));

                 </code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust76/exfaust76.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="tester2">tester2</h2>
<div class="faust-run"><a href="img/src/exfaust77/exfaust77-svg/process.svg" target="_blank"><img src="img/src/exfaust77/exfaust77-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;tester2&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2014&quot;;

//-----------------------------------------------
// Stereo Audio Tester : send a test signal (sine, 
// noise, pink) on a stereo channel
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

pink    = f : (+ ~ g) with {
    f(x) = 0.04957526213389*x - 0.06305581334498*x&#39; + 0.01483220320740*x&#39;&#39;;
    g(x) = 1.80116083982126*x - 0.80257737639225*x&#39;;
};

// User interface
//----------------
transition(n) = \(old,new).(ba.if(old&lt;new, min(old+1.0/n,new), max(old-1.0/n,new))) ~ _;

vol  = hslider(&quot;[2] volume [unit:dB]&quot;, -96, -96, 0, 1): ba.db2linear : si.smoo;
freq = hslider(&quot;[1] freq [unit:Hz][scale:log]&quot;, 440, 40, 20000, 1);
wave = nentry(&quot;[3] signal [style:menu{&#39;white noise&#39;:0;&#39;pink noise&#39;:1;&#39;sine&#39;:2}]&quot;, 0, 0, 2, 1) : int;
dest = nentry(&quot;[4] channel [style:radio{&#39;none&#39;:0;&#39;left&#39;:1;&#39;right&#39;:2;&#39;both&#39;:3}]&quot;, 0, 0, 3, 1) : int;

testsignal  = no.noise, pink(no.noise), os.osci(freq): select3(wave);

process     = vgroup(&quot;Stereo Audio Tester&quot;,
                testsignal*vol 
                &lt;: par(i, 2, *((dest &amp; (i+1)) != 0 : transition(4410))) 
            );</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust77/exfaust77.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="tester">tester</h2>
<div class="faust-run"><a href="img/src/exfaust78/exfaust78-svg/process.svg" target="_blank"><img src="img/src/exfaust78/exfaust78-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;tester&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-----------------------------------------------
// Tester : tests louspeakers
// Send a test signal( sine, noise, pink) to one 
// of 8 loudspeakers
//-----------------------------------------------

import(&quot;stdfaust.lib&quot;);

// TODO: this should be rewritten with the pink noise function of noises.lib
pink    = f : (+ ~ g) with {
    f(x) = 0.04957526213389*x - 0.06305581334498*x&#39; + 0.01483220320740*x&#39;&#39;;
    g(x) = 1.80116083982126*x - 0.80257737639225*x&#39;;
};

// User interface
//----------------
vol             = hslider(&quot;[2] volume [unit:dB]&quot;, -96, -96, 0, 1): ba.db2linear : si.smoo;
freq            = hslider(&quot;[1] freq [unit:Hz]&quot;, 1000, 10, 20000, 1);
dest            = hslider(&quot;[3] destination&quot;, 0, 0, 8, 1);

testsignal      = os.osci(freq)*checkbox(&quot;sine wave&quot;)
                + no.noise * checkbox(&quot;white noise&quot;)
                + pink(no.noise) * ba.db2linear(20)  * checkbox(&quot;pink noise&quot;);

process         = vgroup( &quot;Audio Tester&quot;, 
                    testsignal*vol 
                    &lt;: par(i, 8, *(dest==i)) 
                  );</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust78/exfaust78.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="uitester">UITester</h2>
<div class="faust-run"><a href="img/src/exfaust79/exfaust79-svg/process.svg" target="_blank"><img src="img/src/exfaust79/exfaust79-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;UITester&quot;;
declare version &quot;1.0&quot;;
declare author &quot;O. Guillerminet&quot;;
declare license &quot;BSD&quot;;
declare copyright &quot;(c) O. Guillerminet 2012&quot;;

vbox =          vgroup(&quot;vbox&quot;, 
                    checkbox(&quot;check1&quot;),
                    checkbox(&quot;check2&quot;),
                    nentry(&quot;knob0[style:knob]&quot;, 60, 0, 127, 0.1));

sliders =       hgroup(&quot;sliders&quot;,
                    vslider(&quot;vslider1&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;vslider2&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;vslider3&quot;, 60, 0, 127, 0.1));

knobs =         hgroup(&quot;knobs&quot;,
                    vslider(&quot;knob1[style:knob]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;knob2[style:knob]&quot;, 60, 0, 127, 0.1), 
                    vslider(&quot;knob3[style:knob]&quot;, 60, 0, 127, 0.1));

smallhbox1 =        hgroup(&quot;small box 1&quot;,
                    vslider(&quot;vslider5 [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;vslider6 [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;knob4[style:knob]&quot;, 60, 0, 127, 0.1),
                    nentry(&quot;num1 [unit:f]&quot;, 60, 0, 127, 0.1),
                    vbargraph(&quot;vbar1&quot;, 0, 127));

smallhbox2 =        hgroup(&quot;small box 2&quot;,
                    vslider(&quot;vslider7 [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;vslider8 [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;knob5[style:knob]&quot;, 60, 0, 127, 0.1),
                    nentry(&quot;num2 [unit:f]&quot;, 60, 0, 127, 0.1),
                    vbargraph(&quot;vbar2&quot;, 0, 127));

smallhbox3 =        hgroup(&quot;small box 3&quot;,
                    vslider(&quot;vslider9 [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;vslider10 [unit:m]&quot;, 60, 0, 127, 0.1),
                    vslider(&quot;knob6[style:knob]&quot;, 60, 0, 127, 0.1),
                    nentry(&quot;num3 [unit:f]&quot;, 60, 0, 127, 0.1),
                    vbargraph(&quot;vbar3&quot;, 0, 127));

subhbox1 =      hgroup(&quot;sub box 1&quot;,
                    smallhbox2,
                    smallhbox3);

vmisc =         vgroup(&quot;vmisc&quot;,
                    vslider(&quot;vslider4 [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    button(&quot;button&quot;),
                    hslider(&quot;hslider [unit:Hz]&quot;, 60, 0, 127, 0.1),
                    smallhbox1,
                    subhbox1,
                    hbargraph(&quot;hbar&quot;, 0, 127));

hmisc =         hgroup(&quot;hmisc&quot;,
                    vslider(&quot;vslider4 [unit:f]&quot;, 60, 0, 127, 0.1),
                    button(&quot;button&quot;),
                    hslider(&quot;hslider&quot;, 60, 0, 127, 0.1),
                    nentry(&quot;num [unit:f]&quot;, 60, 0, 127, 0.1),
                    vbargraph(&quot;vbar&quot;, 0, 127),
                    hbargraph(&quot;hbar&quot;, 0, 127));

//------------------------- Process --------------------------------

process =       tgroup(&quot;grp 1&quot;,
                    vbox,
                    sliders,
                    knobs,
                    vmisc,
                    hmisc);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust79/exfaust79.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="old">old</h1>
<h2 id="freeverb">freeverb</h2>
<div class="faust-run"><a href="img/src/exfaust80/exfaust80-svg/process.svg" target="_blank"><img src="img/src/exfaust80/exfaust80-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: freeverb has been reimplemented in reverbs.lib: this version is deprecated

declare name        &quot;freeverb&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c) GRAME 2006&quot;;
declare reference   &quot;https://ccrma.stanford.edu/~jos/pasp/Freeverb.html&quot;;

//======================================================
//
//                      Freeverb
//        Faster version using fixed delays (20% gain)
//
//======================================================

// Constant Parameters
//--------------------

fixedgain   = 0.015; //value of the gain of fxctrl
scalewet    = 3.0;
scaledry    = 2.0;
scaledamp   = 0.4;
scaleroom   = 0.28;
offsetroom  = 0.7;
initialroom = 0.5;
initialdamp = 0.5;
initialwet  = 1.0/scalewet;
initialdry  = 0;
initialwidth= 1.0;
initialmode = 0.0;
freezemode  = 0.5;
stereospread= 23;
allpassfeed = 0.5; //feedback of the delays used in allpass filters


// Filter Parameters
//------------------

combtuningL1    = 1116;
combtuningL2    = 1188;
combtuningL3    = 1277;
combtuningL4    = 1356;
combtuningL5    = 1422;
combtuningL6    = 1491;
combtuningL7    = 1557;
combtuningL8    = 1617;

allpasstuningL1 = 556;
allpasstuningL2 = 441;
allpasstuningL3 = 341;
allpasstuningL4 = 225;


// Control Sliders
//--------------------
// Damp : filters the high frequencies of the echoes (especially active for great values of RoomSize)
// RoomSize : size of the reverberation room
// Dry : original signal
// Wet : reverberated signal

dampSlider      = hslider(&quot;Damp&quot;,0.5, 0, 1, 0.025)*scaledamp;
roomsizeSlider  = hslider(&quot;RoomSize&quot;, 0.9, 0, 1, 0.025)*scaleroom + offsetroom;
wetSlider       = hslider(&quot;Wet&quot;, 0.9, 0, 1, 0.025);
combfeed        = roomsizeSlider;


// Comb and Allpass filters
//-------------------------

allpass(dt,fb) = (_,_ &lt;: (*(fb),_:+:@(dt)), -) ~ _ : (!,_);

comb(dt, fb, damp) = (+:@(dt)) ~ (*(1-damp) : (+ ~ *(damp)) : *(fb));


// Reverb components
//------------------

monoReverb(fb1, fb2, damp, spread)
    = _ &lt;:  comb(combtuningL1+spread, fb1, damp),
            comb(combtuningL2+spread, fb1, damp),
            comb(combtuningL3+spread, fb1, damp),
            comb(combtuningL4+spread, fb1, damp),
            comb(combtuningL5+spread, fb1, damp),
            comb(combtuningL6+spread, fb1, damp),
            comb(combtuningL7+spread, fb1, damp),
            comb(combtuningL8+spread, fb1, damp)
        +&gt;
            allpass (allpasstuningL1+spread, fb2)
        :   allpass (allpasstuningL2+spread, fb2)
        :   allpass (allpasstuningL3+spread, fb2)
        :   allpass (allpasstuningL4+spread, fb2)
        ;

stereoReverb(fb1, fb2, damp, spread)
    = + &lt;:  monoReverb(fb1, fb2, damp, 0), monoReverb(fb1, fb2, damp, spread);


// fxctrl : add an input gain and a wet-dry control to a stereo FX
//----------------------------------------------------------------

fxctrl(g,w,Fx) =  _,_ &lt;: (*(g),*(g) : Fx : *(w),*(w)), *(1-w), *(1-w) +&gt; _,_;

// Freeverb
//---------

freeverb = vgroup(&quot;Freeverb&quot;, fxctrl(fixedgain, wetSlider, stereoReverb(combfeed, allpassfeed, dampSlider, stereospread)));

process = freeverb;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust80/exfaust80.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="phasing">phasing</h1>
<h2 id="flanger">flanger</h2>
<div class="faust-run"><a href="img/src/exfaust81/exfaust81-svg/process.svg" target="_blank"><img src="img/src/exfaust81/exfaust81-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;flanger&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Flanger effect application.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.flanger_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust81/exfaust81.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="phaser">phaser</h2>
<div class="faust-run"><a href="img/src/exfaust82/exfaust82-svg/process.svg" target="_blank"><img src="img/src/exfaust82/exfaust82-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;phaser&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, revised by RM&quot;;
declare description &quot;Phaser demo application.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.phaser2_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust82/exfaust82.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="phaserflangerlab">phaserFlangerLab</h2>
<div class="faust-run"><a href="img/src/exfaust83/exfaust83-svg/process.svg" target="_blank"><img src="img/src/exfaust83/exfaust83-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;phaserFlangerLab&quot;;

import(&quot;stdfaust.lib&quot;);

//process = ol.sawtooth_demo &lt;: 
//  el.flanger_demo : el.phaser2_demo :&gt; fl.spectral_level_demo &lt;: _,_;

fx_stack = 
 vgroup(&quot;[1]&quot;, dm.sawtooth_demo) &lt;:
 vgroup(&quot;[2]&quot;, dm.flanger_demo) : 
 vgroup(&quot;[3]&quot;, dm.phaser2_demo);

level_viewer(x,y) = attach(x, vgroup(&quot;[4]&quot;, dm.spectral_level_demo(x+y))),y;

process = fx_stack : level_viewer;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust83/exfaust83.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="physicalmodeling">physicalModeling</h1>
<h2 id="brass">brass</h2>
<div class="faust-run"><a href="img/src/exfaust84/exfaust84-svg/process.svg" target="_blank"><img src="img/src/exfaust84/exfaust84-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Brass&quot;;
declare description &quot;Simple brass instrument physical model with physical parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.brass_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust84/exfaust84.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="brassmidi">brassMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust85/exfaust85-svg/process.svg" target="_blank"><img src="img/src/exfaust85/exfaust85-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;BrassMIDI&quot;;
declare description &quot;Simple MIDI-controllable brass instrument physical model with physical parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.brass_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust85/exfaust85.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="churchbell">churchBell</h2>
<div class="faust-run"><a href="img/src/exfaust86/exfaust86-svg/process.svg" target="_blank"><img src="img/src/exfaust86/exfaust86-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;ChurchBell&quot;;
declare description &quot;Generic church bell physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.churchBell_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust86/exfaust86.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="clarinet">clarinet</h2>
<div class="faust-run"><a href="img/src/exfaust87/exfaust87-svg/process.svg" target="_blank"><img src="img/src/exfaust87/exfaust87-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Clarinet&quot;;
declare description &quot;Simple clarinet physical model with physical parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.clarinet_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust87/exfaust87.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="clarinetmidi">clarinetMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust88/exfaust88-svg/process.svg" target="_blank"><img src="img/src/exfaust88/exfaust88-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;ClarinetMIDI&quot;;
declare description &quot;Simple MIDI-controllable clarinet physical model with physical parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.clarinet_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust88/exfaust88.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="djembemidi">djembeMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust89/exfaust89-svg/process.svg" target="_blank"><img src="img/src/exfaust89/exfaust89-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;DjembeMIDI&quot;;
declare description &quot;Simple MIDI-controllable djembe physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.djembe_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust89/exfaust89.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="elecguitarmidi">elecGuitarMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust90/exfaust90-svg/process.svg" target="_blank"><img src="img/src/exfaust90/exfaust90-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;ElecGuitarMidi&quot;;
declare description &quot;Simple electric guitar model without effect chain.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

// TODO: We could potentially add an audio effect chain here

process = pm.elecGuitar_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust90/exfaust90.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="englishbell">englishBell</h2>
<div class="faust-run"><a href="img/src/exfaust91/exfaust91-svg/process.svg" target="_blank"><img src="img/src/exfaust91/exfaust91-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;EnglishChurchBell&quot;;
declare description &quot;English church bell physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.englishBell_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust91/exfaust91.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="flute">flute</h2>
<div class="faust-run"><a href="img/src/exfaust92/exfaust92-svg/process.svg" target="_blank"><img src="img/src/exfaust92/exfaust92-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Flute&quot;;
declare description &quot;Simple flute physical model with physical parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.flute_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust92/exfaust92.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="flutemidi">fluteMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust93/exfaust93-svg/process.svg" target="_blank"><img src="img/src/exfaust93/exfaust93-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;FluteMIDI&quot;;
declare description &quot;Simple MIDI-controllable flute physical model with physical parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.flute_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust93/exfaust93.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="frenchbell">frenchBell</h2>
<div class="faust-run"><a href="img/src/exfaust94/exfaust94-svg/process.svg" target="_blank"><img src="img/src/exfaust94/exfaust94-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;FrenchChurchBell&quot;;
declare description &quot;French church bell physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.frenchBell_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust94/exfaust94.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="germanbell">germanBell</h2>
<div class="faust-run"><a href="img/src/exfaust95/exfaust95-svg/process.svg" target="_blank"><img src="img/src/exfaust95/exfaust95-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;GermanChurchBell&quot;;
declare description &quot;German church bell physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.germanBell_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust95/exfaust95.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="guitarmidi">guitarMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust96/exfaust96-svg/process.svg" target="_blank"><img src="img/src/exfaust96/exfaust96-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;GuitarMidi&quot;;
declare description &quot;Simple acoustic guitar model with steel strings.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.guitar_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust96/exfaust96.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="karplus">karplus</h2>
<div class="faust-run"><a href="img/src/exfaust97/exfaust97-svg/process.svg" target="_blank"><img src="img/src/exfaust97/exfaust97-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;KarplusStrong&quot;;
declare description &quot;Simple call of the Karplus-Strong model for the Faust physical modeling library&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.ks_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust97/exfaust97.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="marimbamidi">marimbaMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust98/exfaust98-svg/process.svg" target="_blank"><img src="img/src/exfaust98/exfaust98-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>// WARNING: this model is incomplete and is only here for testing purposes

declare name &quot;MarimbaMIDI&quot;;
declare description &quot;Simple MIDI-controllable marimba physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.marimba_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust98/exfaust98.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="modularinterpinstrmidi">modularInterpInstrMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust99/exfaust99-svg/process.svg" target="_blank"><img src="img/src/exfaust99/exfaust99-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;ModularInterpInstrMidi&quot;;
declare description &quot;String instrument with a modular body&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon &amp; John Granzow, CCRMA (Stanford University), GRAME, University of Michigan&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.modularInterpInstr_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust99/exfaust99.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="nylonguitarmidi">nylonGuitarMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust100/exfaust100-svg/process.svg" target="_blank"><img src="img/src/exfaust100/exfaust100-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;NylonGuitarMidi&quot;;
declare description &quot;Simple acoustic guitar model with nylon strings.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.nylonGuitar_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust100/exfaust100.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="russianbell">russianBell</h2>
<div class="faust-run"><a href="img/src/exfaust101/exfaust101-svg/process.svg" target="_blank"><img src="img/src/exfaust101/exfaust101-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;RussianChurchBell&quot;;
declare description &quot;Russian church bell physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.russianBell_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust101/exfaust101.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="standardbell">standardBell</h2>
<div class="faust-run"><a href="img/src/exfaust102/exfaust102-svg/process.svg" target="_blank"><img src="img/src/exfaust102/exfaust102-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;StandardChurchBell&quot;;
declare description &quot;Standard church bell physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.standardBell_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust102/exfaust102.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="violin">violin</h2>
<div class="faust-run"><a href="img/src/exfaust103/exfaust103-svg/process.svg" target="_blank"><img src="img/src/exfaust103/exfaust103-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Violin&quot;;
declare description &quot;Simple violin physical model controlled with continuous parameters.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.violin_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust103/exfaust103.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="violinmidi">violinMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust104/exfaust104-svg/process.svg" target="_blank"><img src="img/src/exfaust104/exfaust104-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;ViolinMidi&quot;;
declare description &quot;Simple MIDI-controllable violin physical model.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.violin_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust104/exfaust104.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vocalbp">vocalBP</h2>
<div class="faust-run"><a href="img/src/exfaust105/exfaust105-svg/process.svg" target="_blank"><img src="img/src/exfaust105/exfaust105-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Vocal BandPass&quot;;
declare description &quot;Simple source-filter vocal synthesizer.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.SFFormantModelBP_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust105/exfaust105.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vocalbpmidi">vocalBPMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust106/exfaust106-svg/process.svg" target="_blank"><img src="img/src/exfaust106/exfaust106-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Vocal BandPass MIDI&quot;;
declare description &quot;Simple MIDI-controllable source-filter vocal synthesizer.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Romain Michon, CCRMA (Stanford University), GRAME&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.SFFormantModelBP_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust106/exfaust106.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vocalfof">vocalFOF</h2>
<div class="faust-run"><a href="img/src/exfaust107/exfaust107-svg/process.svg" target="_blank"><img src="img/src/exfaust107/exfaust107-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Vocal FOF&quot;;
declare description &quot;FOF vocal synthesizer.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Mike Olsen, CCRMA (Stanford University)&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.SFFormantModelFofSmooth_ui &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust107/exfaust107.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vocalfofmidi">vocalFOFMIDI</h2>
<div class="faust-run"><a href="img/src/exfaust108/exfaust108-svg/process.svg" target="_blank"><img src="img/src/exfaust108/exfaust108-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;Vocal FOF MIDI&quot;;
declare description &quot;MIDI-controllable FOF vocal synthesizer.&quot;;
declare license &quot;MIT&quot;;
declare copyright &quot;(c)Mike Olsen, CCRMA (Stanford University)&quot;;

import(&quot;stdfaust.lib&quot;);

process = pm.SFFormantModelFofSmooth_ui_MIDI &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust108/exfaust108.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="pitchshifting">pitchShifting</h1>
<h2 id="pitchshifter">pitchShifter</h2>
<div class="faust-run"><a href="img/src/exfaust109/exfaust109-svg/process.svg" target="_blank"><img src="img/src/exfaust109/exfaust109-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;pitchShifter&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

 //--------------------------------------
 // very simple real time pitch shifter
 //--------------------------------------
 
import(&quot;stdfaust.lib&quot;);

pitchshifter = vgroup(&quot;Pitch Shifter&quot;, ef.transpose(
                                    hslider(&quot;window (samples)&quot;, 1000, 50, 10000, 1),
                                    hslider(&quot;xfade (samples)&quot;, 10, 1, 10000, 1),
                                    hslider(&quot;shift (semitones) &quot;, 0, -12, +12, 0.1)
                                  )
                );

process = pitchshifter;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust109/exfaust109.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="psychoacoustic">psychoacoustic</h1>
<h2 id="harmonicexciter">harmonicExciter</h2>
<div class="faust-run"><a href="img/src/exfaust110/exfaust110-svg/process.svg" target="_blank"><img src="img/src/exfaust110/exfaust110-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare exciter_name &quot;harmonicExciter&quot;;
declare exciter_author &quot;Priyanka Shekar (pshekar@ccrma.stanford.edu), revised by RM&quot;;
declare exciter_copyright &quot;Copyright (c) 2013 Priyanka Shekar&quot;;
declare exciter_version &quot;1.0&quot;;
declare exciter_license &quot;MIT License (MIT)&quot;;
declare description &quot;Psychoacoustic harmonic exciter, with GUI&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.exciter;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust110/exfaust110.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="reverb">reverb</h1>
<h2 id="fdnrev">fdnRev</h2>
<div class="faust-run"><a href="img/src/exfaust111/exfaust111-svg/process.svg" target="_blank"><img src="img/src/exfaust111/exfaust111-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;fdnRev&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, Revised by RM&quot;;
declare description &quot;A feedback delay network reverb.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.fdnrev0_demo(16,5,3);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust111/exfaust111.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="freeverb-1">freeverb</h2>
<div class="faust-run"><a href="img/src/exfaust112/exfaust112-svg/process.svg" target="_blank"><img src="img/src/exfaust112/exfaust112-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;freeverb&quot;;
declare version &quot;0.0&quot;;
declare author &quot;RM&quot;;
declare description &quot;Freeverb demo application.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.freeverb_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust112/exfaust112.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="reverbdesigner">reverbDesigner</h2>
<div class="faust-run"><a href="img/src/exfaust113/exfaust113-svg/process.svg" target="_blank"><img src="img/src/exfaust113/exfaust113-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;reverbDesigner&quot;;

import(&quot;stdfaust.lib&quot;);

N = 16;     // Feedback Delay Network (FDN) order (power of 2, 2 to 16)
NB =  5;    // Number of T60-controlled frequency-bands (3 or more)
BSO =  3;   // Order of each lowpass/highpass bandsplit (odd positive integer)

process = dm.fdnrev0_demo(N,NB,BSO);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust113/exfaust113.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="reverbtester">reverbTester</h2>
<div class="faust-run"><a href="img/src/exfaust114/exfaust114-svg/process.svg" target="_blank"><img src="img/src/exfaust114/exfaust114-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;reverbTester&quot;;
declare version &quot;0.0&quot;;
declare author &quot;RM&quot;;
declare description &quot;Handy test inputs for reverberator demos below.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.stereo_reverb_tester;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust114/exfaust114.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="zitarev">zitaRev</h2>
<div class="faust-run"><a href="img/src/exfaust115/exfaust115-svg/process.svg" target="_blank"><img src="img/src/exfaust115/exfaust115-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;zitaRev&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, Revised by RM&quot;;
declare description &quot;Example GUI for `zita_rev1_stereo` (mostly following the Linux `zita-rev1` GUI).&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.zita_rev1; </code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust115/exfaust115.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="zitarevfdn">zitaRevFDN</h2>
<div class="faust-run"><a href="img/src/exfaust116/exfaust116-svg/process.svg" target="_blank"><img src="img/src/exfaust116/exfaust116-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name &quot;zitaRevFDN&quot;;
declare version &quot;0.0&quot;;
declare author &quot;JOS, Revised by RM&quot;;
declare description &quot;Reverb demo application based on `zita_rev_fdn`.&quot;;

import(&quot;stdfaust.lib&quot;);

process = dm.zita_rev_fdn_demo;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust116/exfaust116.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="sam">SAM</h1>
<h1 id="smartkeyboard">smartKeyboard</h1>
<h2 id="acguitar">acGuitar</h2>
<div class="faust-run"><a href="img/src/exfaust117/exfaust117-svg/process.svg" target="_blank"><img src="img/src/exfaust117/exfaust117-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//############################### acGuitar.dsp #################################
// Faust instrument specifically designed for `faust2smartkeyb` where 6 virtual
// nylon strings can be strummed and plucked using a dedicated keyboard. The
// extra &quot;strumming keyboard&quot; could be easily replaced by an external strumming
// interface while the touch screen could keep being used to change the pitch
// of the strings.
//
// ## `SmartKeyboard` Use Strategy
//
// The first 6 keyboards implement each individual string of the instrument. A
// seventh keybaord is used a strumming/plucking interface. As mentionned
// previously, it could be easily replaced by an external interface.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets.
// However it was specifically designed to be used with `faust2smartkeyb`. For
// best results, we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp acGuitar.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Aug. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//##############################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;7&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Rounding Mode&#39;:&#39;2&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;14&#39;,
  &#39;Keyboard 1 - Number of Keys&#39;:&#39;14&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;14&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;14&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;14&#39;,
    &#39;Keyboard 5 - Number of Keys&#39;:&#39;14&#39;,
    &#39;Keyboard 6 - Number of Keys&#39;:&#39;6&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;52&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;57&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;62&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;67&#39;,
    &#39;Keyboard 4 - Lowest Key&#39;:&#39;71&#39;,
    &#39;Keyboard 5 - Lowest Key&#39;:&#39;76&#39;,
    &#39;Keyboard 0 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 2 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 3 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 4 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 5 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 6 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 6 - Send Key Status&#39;:&#39;1&#39;,
    &#39;Keyboard 6 - Key 0 - Label&#39;:&#39;S0&#39;,
    &#39;Keyboard 6 - Key 1 - Label&#39;:&#39;S1&#39;,
    &#39;Keyboard 6 - Key 2 - Label&#39;:&#39;S2&#39;,
    &#39;Keyboard 6 - Key 3 - Label&#39;:&#39;S3&#39;,
    &#39;Keyboard 6 - Key 4 - Label&#39;:&#39;S4&#39;,
    &#39;Keyboard 6 - Key 5 - Label&#39;:&#39;S5&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// SMARTKEYBOARD PARAMS
kbfreq(0) = hslider(&quot;kb0freq&quot;,164.8,20,10000,0.01);
kbbend(0) = hslider(&quot;kb0bend&quot;,1,0,10,0.01);
kbfreq(1) = hslider(&quot;kb1freq&quot;,220,20,10000,0.01);
kbbend(1) = hslider(&quot;kb1bend&quot;,1,0,10,0.01);
kbfreq(2) = hslider(&quot;kb2freq&quot;,293.7,20,10000,0.01);
kbbend(2) = hslider(&quot;kb2bend&quot;,1,0,10,0.01);
kbfreq(3) = hslider(&quot;kb3freq&quot;,392,20,10000,0.01);
kbbend(3) = hslider(&quot;kb3bend&quot;,1,0,10,0.01);
kbfreq(4) = hslider(&quot;kb4freq&quot;,493.9,20,10000,0.01);
kbbend(4) = hslider(&quot;kb4bend&quot;,1,0,10,0.01);
kbfreq(5) = hslider(&quot;kb5freq&quot;,659.2,20,10000,0.01);
kbbend(5) = hslider(&quot;kb5bend&quot;,1,0,10,0.01);
kb6kstatus(0) = hslider(&quot;kb6k0status&quot;,0,0,1,1) &lt;: ==(1) | ==(4) : int;
kb6kstatus(1) = hslider(&quot;kb6k1status&quot;,0,0,1,1) &lt;: ==(1) | ==(4) : int;
kb6kstatus(2) = hslider(&quot;kb6k2status&quot;,0,0,1,1) &lt;: ==(1) | ==(4) : int;
kb6kstatus(3) = hslider(&quot;kb6k3status&quot;,0,0,1,1) &lt;: ==(1) | ==(4) : int;
kb6kstatus(4) = hslider(&quot;kb6k4status&quot;,0,0,1,1) &lt;: ==(1) | ==(4) : int;
kb6kstatus(5) = hslider(&quot;kb6k5status&quot;,0,0,1,1) &lt;: ==(1) | ==(4) : int;

// MODEL PARAMETERS
// strings length
sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo;
// pluck position is controlled by the x axis of the accel
pluckPosition =
    hslider(&quot;pluckPosition[acc: 1 0 -10 0 10]&quot;,0.5,0,1,0.01) : si.smoo;

// ASSEMBLING MODELS
// number of strings
nStrings = 6;
guitar = par(i,nStrings,
    kb6kstatus(i) : ba.impulsify : // using &quot;raw&quot; impulses to drive the models
    pm.nylonGuitarModel(sl(i),pluckPosition)) :&gt; _;

process = guitar &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust117/exfaust117.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="bells">bells</h2>
<div class="faust-run"><a href="img/src/exfaust118/exfaust118-svg/process.svg" target="_blank"><img src="img/src/exfaust118/exfaust118-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################ bells.dsp ###################################
// Faust instrument specifically designed for `faust2smartkeyb` where the
// physical models of 4 different bells can be played using screen pads. The
// models are taken from `physmodels.lib`.
//
// ## `SmartKeyboard` Use Strategy
//
// The `SmartKeyboard` interface is used to implement percussion pads where
// the X/Y position of fingers is retrieved to control the strike position on
// the bells.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets.
// However it was specifically designed to be used with `faust2smartkeyb`. For
// best results, we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp bells.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Aug. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//##############################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;2&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;2&#39;,
  &#39;Keyboard 1 - Number of Keys&#39;:&#39;2&#39;,
    &#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;,
  &#39;Keyboard 1 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
  &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send Key Status&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Key Status&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Key 0 - Label&#39;:&#39;English Bell&#39;,
    &#39;Keyboard 0 - Key 1 - Label&#39;:&#39;French Bell&#39;,
    &#39;Keyboard 1 - Key 0 - Label&#39;:&#39;German Bell&#39;,
    &#39;Keyboard 1 - Key 1 - Label&#39;:&#39;Russian Bell&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// SMARTKEYBOARD PARAMS
kb0k0status = hslider(&quot;kb0k0status&quot;,0,0,1,1) : min(1) : int;
kb0k1status = hslider(&quot;kb0k1status&quot;,0,0,1,1) : min(1) : int;
kb1k0status = hslider(&quot;kb1k0status&quot;,0,0,1,1) : min(1) : int;
kb1k1status = hslider(&quot;kb1k1status&quot;,0,0,1,1) : min(1) : int;
x = hslider(&quot;x&quot;,1,0,1,0.001);
y = hslider(&quot;y&quot;,1,0,1,0.001);

// MODEL PARAMETERS
strikeCutoff = 6500;
strikeSharpness = 0.5;
strikeGain = 1;
// synthesize 10 modes out of 50
nModes = 10;
// resonance duration is 30s
t60 = 30;
// number of excitation pos (retrieved from model)
nExPos = 7;
// computing excitation position from X and Y
exPos = min((x*2-1 : abs),(y*2-1 : abs))*(nExPos-1) : int;

// ASSEMBLING MODELS
bells =
    (kb0k0status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.englishBellModel(nModes,exPos,t60,1,3)) +
    (kb0k1status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.frenchBellModel(nModes,exPos,t60,1,3)) +
    (kb1k0status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.germanBellModel(nModes,exPos,t60,1,2.5)) +
    (kb1k1status : pm.strikeModel(10,strikeCutoff,strikeSharpness,strikeGain) : pm.russianBellModel(nModes,exPos,t60,1,3)) :&gt; *(0.2);

process = bells &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust118/exfaust118.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="bowed">bowed</h2>
<div class="faust-run"><a href="img/src/exfaust119/exfaust119-svg/process.svg" target="_blank"><img src="img/src/exfaust119/exfaust119-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//##################################### bowed.dsp ########################################
// Faust instrument specifically designed for `faust2smartkeyb` implementing a
// non-polyphonic synthesizer (e.g., physical model; etc.) using a combination of
// different types of UI elements.
//
// ## `SmartKeyboard` Use Strategy
//
// 5 keyboards are declared (4 actual keyboards and 1 control surface). We want to
// disable the voice allocation system and we want to activate a voice on start-up
// so that all strings are constantly running so we set `Max Keyboard Polyphony` to
// 0. Since we don&#39;t want the first 4 keyboards to send the X and Y position of
// fingers on the screen, we set `Send X` and `Send Y` to 0 for all these keyboards.
// Similarly, we don&#39;t want the fifth keyboard to send pitch information to the synth
// so we set `Send Freq` to 0 for that keyboard. Finally, we deactivate piano keyboard
// mode for the fifth keyboard to make sure that color doesn&#39;t change when the key is
// touch and that note names are not displayed.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp midiOnly.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;5&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Rounding Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 4 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 2 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 3 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Send Y&#39;:&#39;0&#39;,
    &#39;Keyboard 2 - Send Y&#39;:&#39;0&#39;,
    &#39;Keyboard 3 - Send Y&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;55&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;62&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;69&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;76&#39;,
    &#39;Keyboard 4 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 4 - Key 0 - Label&#39;:&#39;Bow&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// parameters
f = hslider(&quot;freq&quot;,400,50,2000,0.01);
bend = hslider(&quot;bend&quot;,1,0,10,0.01);
keyboard = hslider(&quot;keyboard&quot;,0,0,5,1) : int;
key = hslider(&quot;key&quot;,0,0,18,1) : int;
x = hslider(&quot;x&quot;,0.5,0,1,0.01) : si.smoo;
y = hslider(&quot;y&quot;,0,0,1,0.01) : si.smoo;

// mapping
freq = f*bend;
// dirty motion tracker
velocity = x-x&#39; : abs : an.amp_follower_ar(0.1,1) : *(8000) : min(1);

// 4 &quot;strings&quot;
synthSet = par(i,4,synth(localFreq(i),velocity)) :&gt; _
with{
    localFreq(i) = freq : ba.sAndH(keyboard == i) : si.smoo;
    synth(freq,velocity) = sy.fm((freq,freq + freq*modFreqRatio),index*velocity)*velocity
    with{
        index = 1000;
        modFreqRatio = y*0.3;
    };
};

process = synthSet &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust119/exfaust119.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="brass-1">brass</h2>
<div class="faust-run"><a href="img/src/exfaust120/exfaust120-svg/process.svg" target="_blank"><img src="img/src/exfaust120/exfaust120-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//############################### brass.dsp ###################################
// Faust instrument specifically designed for `faust2smartkeyb` where a
// trumpet physical model is controlled using some of the built-in sensors of
// the device and the touchscreen. Some of these elements could be replaced by
// external controllers (e.g., breath/mouth piece controller).
//
// ## `SmartKeyboard` Use Strategy
//
// 1 keyboard is used to implement the pistons of the trumpet (3 keys) and the
// other allows to control the lips tension.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets.
// However it was specifically designed to be used with `faust2smartkeyb`. For
// best results, we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp brass.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Aug. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//##############################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;2&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;1&#39;,
  &#39;Keyboard 1 - Number of Keys&#39;:&#39;3&#39;,
    &#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;,
  &#39;Keyboard 1 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
  &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send Key X&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Key Status&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Key 0 - Label&#39;:&#39;Lips Tension&#39;,
    &#39;Keyboard 1 - Key 0 - Label&#39;:&#39;P1&#39;,
    &#39;Keyboard 1 - Key 1 - Label&#39;:&#39;P2&#39;,
    &#39;Keyboard 1 - Key 2 - Label&#39;:&#39;P3&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// SMARTKEYBOARD PARAMS
kb0k0x = hslider(&quot;kb0k0x&quot;,0,0,1,1);
kb1k0status = hslider(&quot;kb1k0status&quot;,0,0,1,1) : min(1) : int;
kb1k1status = hslider(&quot;kb1k1status&quot;,0,0,1,1) : min(1) : int;
kb1k2status = hslider(&quot;kb1k2status&quot;,0,0,1,1) : min(1) : int;

// MODEL PARAMETERS
// pressure is controlled by accelerometer
pressure = hslider(&quot;pressure[acc: 1 1 -10 0 10]&quot;,0,0,1,0.01) : si.smoo;
breathGain = 0.005; breathCutoff = 2000;
vibratoFreq = 5; vibratoGain = 0;
//pitch when no pistons are pushed
basePitch = 48; // C4
// calculate pitch shift in function of piston combination
pitchShift =
  ((kb1k0status == 0) &amp; (kb1k1status == 1) &amp; (kb1k2status == 0))*(1) +
  ((kb1k0status == 1) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0))*(2) +
  ((kb1k0status == 1) &amp; (kb1k1status == 1) &amp; (kb1k2status == 0))*(3) +
  ((kb1k0status == 0) &amp; (kb1k1status == 1) &amp; (kb1k2status == 1))*(4) +
  ((kb1k0status == 1) &amp; (kb1k1status == 0) &amp; (kb1k2status == 1))*(5) +
  ((kb1k0status == 1) &amp; (kb1k1status == 1) &amp; (kb1k2status == 1))*(6);
// tube length is calculated based on piston combination
tubeLength = basePitch-pitchShift : ba.midikey2hz : pm.f2l : si.smoo;
// lips tension is controlled using pad on screen
lipsTension = kb0k0x : si.smoo;
// default mute value
mute = 0.5;

// ASSEMBLING MODEL
model =
    pm.blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain) :
  pm.brassModel(tubeLength,lipsTension,mute);

process = model &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust120/exfaust120.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="clarinet-1">clarinet</h2>
<div class="faust-run"><a href="img/src/exfaust121/exfaust121-svg/process.svg" target="_blank"><img src="img/src/exfaust121/exfaust121-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//############################### clarinet.dsp #################################
// Faust instrument specifically designed for `faust2smartkeyb` where a
// clarinet physical model is controlled by an interface implementing
// fingerings similar to that of a the real instrument. The pressure of the
// breath in the mouthpiece of the clarinet is controlled by blowing on the
// built-in microphone of the device.
//
// ## `SmartKeyboard` Use Strategy
//
// The device is meant to be held with 2 hands vertically in order to put all
// fingers on the screen at the same time. Key combinations determine the
// pitch of the instrument. A single voice is constantly ran.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets.
// However it was specifically designed to be used with `faust2smartkeyb`. For
// best results, we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] clarinet.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Aug. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//##############################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;2&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;4&#39;,
  &#39;Keyboard 1 - Number of Keys&#39;:&#39;5&#39;,
    &#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;,
  &#39;Keyboard 1 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
  &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send Key Status&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Key Status&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Key 3 - Label&#39;:&#39;O+&#39;,
    &#39;Keyboard 1 - Key 4 - Label&#39;:&#39;O-&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// SMARTKEYBOARD PARAMS
kb0k0status = hslider(&quot;kb0k0status&quot;,0,0,1,1) : min(1) : int;
kb0k1status = hslider(&quot;kb0k1status&quot;,0,0,1,1) : min(1) : int;
kb0k2status = hslider(&quot;kb0k2status&quot;,0,0,1,1) : min(1) : int;
kb0k3status = hslider(&quot;kb0k3status&quot;,0,0,1,1) : min(1) : int;
kb1k0status = hslider(&quot;kb1k0status&quot;,0,0,1,1) : min(1) : int;
kb1k1status = hslider(&quot;kb1k1status&quot;,0,0,1,1) : min(1) : int;
kb1k2status = hslider(&quot;kb1k2status&quot;,0,0,1,1) : min(1) : int;
kb1k3status = hslider(&quot;kb1k3status&quot;,0,0,1,1) : min(1) : int;
kb1k4status = hslider(&quot;kb1k4status&quot;,0,0,1,1) : min(1) : int;

// MODEL PARAMETERS
reedStiffness = hslider(&quot;reedStiffness[acc: 1 1 -10 0 10]&quot;,0,0,1,0.01) : si.smoo;
basePitch = 73; // C#4
pitchShift = // calculate pitch shfit in function of &quot;keys&quot; combination
  ((kb0k0status == 0) &amp; (kb0k1status == 1) &amp; (kb0k2status == 0) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-1) + // C
    ((kb0k0status == 1) &amp; (kb0k1status == 0) &amp; (kb0k2status == 0) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-2) + // B
    ((kb0k0status == 1) &amp; (kb0k1status == 0) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-3) + // Bb
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 0) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-4) + // A
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 0) &amp;
        (kb1k0status == 1) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-5) + // G#
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-6) + // G
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 1) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-7) + // F#
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 1) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-8) + // F
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 1) &amp; (kb1k1status == 1) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 0))*(-9) + // E
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 1) &amp; (kb1k1status == 1) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 1))*(-10) + // Eb
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 1) &amp; (kb1k1status == 1) &amp; (kb1k2status == 1) &amp;
        (kb1k3status == 0))*(-11) + // D
    ((kb0k0status == 0) &amp; (kb0k1status == 0) &amp; (kb0k2status == 0) &amp;
        (kb1k0status == 0) &amp; (kb1k1status == 0) &amp; (kb1k2status == 0) &amp;
        (kb1k3status == 1))*(-12) + // C#
    ((kb0k0status == 1) &amp; (kb0k1status == 1) &amp; (kb0k2status == 1) &amp;
        (kb1k0status == 1) &amp; (kb1k1status == 1) &amp; (kb1k2status == 1) &amp;
        (kb1k3status == 1))*(-13); // C
octaveShiftUp = +(kb0k3status : ba.impulsify)~_; // counting up
octaveShiftDown = +(kb1k4status : ba.impulsify)~_; // counting down
octaveShift = (octaveShiftUp-octaveShiftDown)*(12);
// tube length is just smoothed: could be improved
tubeLength = basePitch+pitchShift+octaveShift : ba.midikey2hz : pm.f2l : si.smoo;
bellOpening = 0.5;

// ASSEMBLING MODEL
model(pressure) = pm.clarinetModel(tubeLength,pressure,reedStiffness,bellOpening);

// pressure is estimated from mic signal
process = an.amp_follower_ud(0.02,0.02)*0.7 : model &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust121/exfaust121.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="crazyguiro">crazyGuiro</h2>
<div class="faust-run"><a href="img/src/exfaust122/exfaust122-svg/process.svg" target="_blank"><img src="img/src/exfaust122/exfaust122-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### crazyGuiro.dsp #####################################
// A simple smart phone &quot;Guiro&quot; where the touch screen is used to drive the instrument and
// select its pitch and where the x and y axis of the accelerometer control the
// resonance properties of the instrument.
//
// ## `SmartKeyboard` Use Strategy
//
// Since the sounds generated by this synth are very short, the strategy here is to take
// advantage of the polyphony capabilities of the iOSKeyboard architecture by creating
// a new voice every time a new key is pressed. Since the `SmartKeyboard` interface has a
// large number of keys here (128), lots of sounds are generated when sliding a
// finger across the keyboard. Also, it&#39;s interesting to notice that the `freq` parameter
// is not used here. Instead `keyboard` and `key` are used which allows us to easily
// make custom mappings.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] crazyGuiro.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

import(&quot;stdfaust.lib&quot;);


//========================= Smart Keyboard Configuration =================================
// 8 keyboards, each has 16 keys, none of them display key names.
//========================================================================================

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;8&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 5 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 6 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 7 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 2 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 3 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 4 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 5 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 6 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 7 - Piano Keyboard&#39;:&#39;0&#39;
}&quot;;


//================================ Instrument Parameters =================================
// Creates the connection between the synth and the mobile device
//========================================================================================

// the current keyboard
keyboard = hslider(&quot;keyboard&quot;,0,0,2,1);
// the current key of the current keyboard
key = hslider(&quot;key&quot;,0,0,2,1);
// the wet factor of the reverb
wet = hslider(&quot;wet[acc: 0 0 -10 0 10]&quot;,0,0,1,0.01);
// the resonance factor of the reverb
res = hslider(&quot;res[acc: 1 0 -10 0 10]&quot;,0.5,0,1,0.01);
// smart keyboard gate parameter
gate = button(&quot;gate&quot;);


//=================================== Parameters Mapping =================================
//========================================================================================

// the resonance frequency of each click of the Guiro changes in function of
// the selected keyboard and key on it
minKey = 50; // min key of lowest keyboard
keySkipKeyboard = 8; // key skip per keyboard
drumResFreq = (key+minKey)+(keyboard*keySkipKeyboard) : ba.midikey2hz;
reverbWet = wet : si.smoo;
reverbRes = wet : si.smoo;

// filter q
q = 8;

//============================================ DSP =======================================
//========================================================================================

reverb(wet,res)  =  _ &lt;: *(1-wet),(*(wet) : re.mono_freeverb(res, 0.5, 0.5, 0)) :&gt; _;

process = sy.popFilterDrum(drumResFreq,q,gate) : reverb(wet,res) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust122/exfaust122.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="drums">drums</h2>
<div class="faust-run"><a href="img/src/exfaust123/exfaust123-svg/process.svg" target="_blank"><img src="img/src/exfaust123/exfaust123-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//##################################### drums.dsp ########################################
// Faust instrument specifically designed for `faust2smartkeyb` where 3 drums can
// be controlled using pads. The X/Y postion of fingers is detected on each key
// and use to control the strike postion on the virtual membrane.
//
// ## `SmartKeyboard` Use Strategy
//
// The drum physical model used here is implemented to be generic so that its
// fundamental frequency can be changed for each voice. `SmartKeyboard` is used
// in polyphonic mode so each new strike on the interface corresponds to a new
// new voice.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp drums.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

// Interface with 2 keyboards of 2 and 1 keys (3 pads)
// Static mode is used so that keys don&#39;t change color when touched
// Note labels are hidden
// Piano Keyboard mode is deactivated so all the keys look the same
declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;2&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;2&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Key 0 - Label&#39;:&#39;High&#39;,
    &#39;Keyboard 0 - Key 1 - Label&#39;:&#39;Mid&#39;,
    &#39;Keyboard 1 - Key 0 - Label&#39;:&#39;Low&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// standard parameters
gate = button(&quot;gate&quot;);
x = hslider(&quot;x&quot;,1,0,1,0.001);
y = hslider(&quot;y&quot;,1,0,1,0.001);
keyboard = hslider(&quot;keyboard&quot;,0,0,1,1) : int;
key = hslider(&quot;key&quot;,0,0,1,1) : int;

drumModel = pm.djembe(rootFreq,exPos,strikeSharpness,gain,gate)
with{
    // frequency of the lowest drum
    bFreq = 60;
    // retrieving pad ID (0-2)
    padID = 2-(keyboard*2+key);
    // drum root freq is computed in function of pad number
    rootFreq = bFreq*(padID+1);
    // excitation position
    exPos = min((x*2-1 : abs),(y*2-1 : abs));
    strikeSharpness = 0.5;
    gain = 2;
};

process = drumModel &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust123/exfaust123.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="dubdub">dubDub</h2>
<div class="faust-run"><a href="img/src/exfaust124/exfaust124-svg/process.svg" target="_blank"><img src="img/src/exfaust124/exfaust124-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### dubDub.dsp #####################################
// A simple smartphone abstract instrument than can be controlled using the touch
// screen and the accelerometers of the device.
//
// ## `SmartKeyboard` Use Strategy
//
// The idea here is to use the `SmartKeyboard` interface as an X/Y control pad by just
// creating one keyboard with on key and by retrieving the X and Y position on that single
// key using the `x` and `y` standard parameters. Keyboard mode is deactivated so that
// the color of the pad doesn&#39;t change when it is pressed.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] dubDub.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

declare name &quot;dubDub&quot;;

import(&quot;stdfaust.lib&quot;);

//========================= Smart Keyboard Configuration =================================
// (1 keyboards with 1 key configured as a pad.
//========================================================================================

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;
}&quot;;


//================================ Instrument Parameters =================================
// Creates the connection between the synth and the mobile device
//========================================================================================

// SmartKeyboard X parameter
x = hslider(&quot;x&quot;,0,0,1,0.01);
// SmartKeyboard Y parameter
y = hslider(&quot;y&quot;,0,0,1,0.01);
// SmartKeyboard gate parameter
gate = button(&quot;gate&quot;);
// modulation frequency is controlled with the x axis of the accelerometer
modFreq = hslider(&quot;modFeq[acc: 0 0 -10 0 10]&quot;,9,0.5,18,0.01);
// general gain is controlled with the y axis of the accelerometer
gain = hslider(&quot;gain[acc: 1 0 -10 0 10]&quot;,0.5,0,1,0.01);


//=================================== Parameters Mapping =================================
//========================================================================================

// sawtooth frequency
minFreq = 80;
maxFreq = 500;
freq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1);

// filter q
q = 8;

// filter cutoff frequency is modulate with a triangle wave
minFilterCutoff = 50;
maxFilterCutoff = 5000;
filterModFreq = modFreq : si.smoo;
filterCutoff = (1-os.lf_trianglepos(modFreq)*(1-y))*(maxFilterCutoff-minFilterCutoff)+minFilterCutoff;

// general gain of the synth
generalGain = gain : ba.lin2LogGain : si.smoo;


//============================================ DSP =======================================
//========================================================================================

process = sy.dubDub(freq,filterCutoff,q,gate)*generalGain &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust124/exfaust124.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="elecguitar">elecGuitar</h2>
<div class="faust-run"><a href="img/src/exfaust125/exfaust125-svg/process.svg" target="_blank"><img src="img/src/exfaust125/exfaust125-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### elecGuitar.dsp #####################################
// Faust instruments specifically designed for `faust2smartkeyb` where an electric
// guitar physical model is controlled using an isomorphic keyboard. Rock on!
//
// ## `SmartKeyboard` Use Strategy
//
// we want to create an isomorphic keyboard where each keyboard is monophonic and
// implements a &quot;string&quot;. Keyboards should be one fourth apart from each other
// (more or less like on a guitar). We want to be able to slide between keyboards
// (strum) to trigger a new note (voice) and we want new fingers on a keyboard to
// &quot;steal&quot; the pitch from the previous finger (sort of hammer on).
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect elecGuitarEffecr.dsp elecGuitar.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017:
// https://ccrma.stanford.edu/~rmichon
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

// Interface with 6 monophonic keyboards one fourth apart from each other
declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;6&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 5 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;72&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;67&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;62&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;57&#39;,
    &#39;Keyboard 4 - Lowest Key&#39;:&#39;52&#39;,
    &#39;Keyboard 5 - Lowest Key&#39;:&#39;47&#39;,
    &#39;Rounding Mode&#39;:&#39;2&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// standard parameters
f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
s = hslider(&quot;sustain[midi:ctrl 64]&quot;,0,0,1,1); // for sustain pedal
t = button(&quot;gate&quot;);

// mapping params
gate = t+s : min(1);
freq = f*bend : max(60); // min freq is 60 Hz

stringLength = freq : pm.f2l;
pluckPosition = 0.8;
mute = gate : si.polySmooth(gate,0.999,1);

process = pm.elecGuitar(stringLength,pluckPosition,mute,gain,gate) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust125/exfaust125.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="fm">fm</h2>
<div class="faust-run"><a href="img/src/exfaust126/exfaust126-svg/process.svg" target="_blank"><img src="img/src/exfaust126/exfaust126-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//###################################### fm.dsp ##########################################
// A simple smart phone percussion abstract sound toy based on an FM synth.
//
// ## `SmartKeyboard` Use Strategy
//
// The idea here is to use the `SmartKeyboard` interface as an X/Y control pad by just
// creating one keyboard with on key and by retrieving the X and Y position on that single
// key using the `x` and `y` standard parameters. Keyboard mode is deactivated so that
// the color of the pad doesn&#39;t change when it is pressed.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] crazyGuiro.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

declare name &quot;fm&quot;;

import(&quot;stdfaust.lib&quot;);

//========================= Smart Keyboard Configuration =================================
// (1 keyboards with 1 key configured as a pad.
//========================================================================================

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;
}&quot;;

//================================ Instrument Parameters =================================
// Creates the connection between the synth and the mobile device
//========================================================================================

// SmartKeyboard X parameter
x = hslider(&quot;x&quot;,0,0,1,0.01);
// SmartKeyboard Y parameter
y = hslider(&quot;y&quot;,0,0,1,0.01);
// SmartKeyboard gate parameter
gate = button(&quot;gate&quot;) ;
// mode resonance duration is controlled with the x axis of the accelerometer
modFreqRatio = hslider(&quot;res[acc: 0 0 -10 0 10]&quot;,1,0,2,0.01) : si.smoo;

//=================================== Parameters Mapping =================================
//========================================================================================

// carrier frequency
minFreq = 80;
maxFreq = 500;
cFreq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1);

// modulator frequency
modFreq = cFreq*modFreqRatio;

// modulation index
modIndex = y*1000 : si.smoo;

//============================================ DSP =======================================
//========================================================================================

// since the generated sound is pretty chaotic, there is no need for an envelope generator
fmSynth = sy.fm((cFreq,modFreq),(modIndex))*(gate : si.smoo)*0.5;

process = fmSynth;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust126/exfaust126.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="frog">frog</h2>
<div class="faust-run"><a href="img/src/exfaust127/exfaust127-svg/process.svg" target="_blank"><img src="img/src/exfaust127/exfaust127-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### frog.dsp #####################################
// A simple smart phone abstract instrument than can be controlled using the touch
// screen and the accelerometers of the device.
//
// ## `SmartKeyboard` Use Strategy
//
// The idea here is to use the `SmartKeyboard` interface as an X/Y control pad by just
// creating one keyboard with on key and by retrieving the X and Y position on that single
// key using the `x` and `y` standard parameters. Keyboard mode is deactivated so that
// the color of the pad doesn&#39;t change when it is pressed.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] frog.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

declare name &quot;frog&quot;;

import(&quot;stdfaust.lib&quot;);

//========================= Smart Keyboard Configuration =================================
// (1 keyboards with 1 key configured as a pad.
//========================================================================================

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;
}&quot;;

//================================ Instrument Parameters =================================
// Creates the connection between the synth and the mobile device
//========================================================================================

// SmartKeyboard X parameter
x = hslider(&quot;x&quot;,0,0,1,0.01);
// SmartKeyboard Y parameter
y = hslider(&quot;y&quot;,0,0,1,0.01);
// SmartKeyboard gate parameter
gate = button(&quot;gate&quot;);
// the cutoff frequency of the filter is controlled with the x axis of the accelerometer
cutoff = hslider(&quot;cutoff[acc: 0 0 -10 0 10]&quot;,2500,50,5000,0.01);

//=================================== Parameters Mapping =================================
//========================================================================================

maxFreq = 100;
minFreq = 1;
freq = x*(maxFreq-minFreq) + minFreq : si.polySmooth(gate,0.999,1);

maxQ = 40;
minQ = 1;
q = (1-y)*(maxQ-minQ) + minQ : si.smoo;
filterCutoff = cutoff : si.smoo;

//============================================ DSP =======================================
//========================================================================================

process = sy.dubDub(freq,filterCutoff,q,gate) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust127/exfaust127.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="harp">harp</h2>
<div class="faust-run"><a href="img/src/exfaust128/exfaust128-svg/process.svg" target="_blank"><img src="img/src/exfaust128/exfaust128-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//######################################## harp.dsp ######################################
// A simple smart phone based harp (if we dare to call it like that). 
//
// ## `SmartKeyboard` Use Strategy
//
// Since the sounds generated by this synth are very short, the strategy here is to take
// advantage of the polyphony capabilities of the iOSKeyboard architecture by creating
// a new voice every time a new key is pressed. Since the `SmartKeyboard` interface has a 
// large number of keys here (128), lots of sounds are generated when sliding a 
// finger across the keyboard.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] harp.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

declare name &quot;harp&quot;;

import(&quot;stdfaust.lib&quot;);

//========================= Smart Keyboard Configuration ================================= 
// (8 keyboards with 16 keys configured as a pitch matrix.
//========================================================================================

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;8&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 5 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 6 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 7 - Number of Keys&#39;:&#39;16&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;40&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;45&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;50&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;55&#39;,
    &#39;Keyboard 4 - Lowest Key&#39;:&#39;60&#39;,
    &#39;Keyboard 5 - Lowest Key&#39;:&#39;65&#39;,
    &#39;Keyboard 6 - Lowest Key&#39;:&#39;70&#39;,
    &#39;Keyboard 7 - Lowest Key&#39;:&#39;75&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 2 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 3 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 4 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 5 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 6 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 7 - Piano Keyboard&#39;:&#39;0&#39;
}&quot;;

//================================ Instrument Parameters =================================
// Creates the connection between the synth and the mobile device
//========================================================================================

// the string resonance in second is controlled by the x axis of the accelerometer
res = hslider(&quot;res[acc: 0 0 -10 0 10]&quot;,2,0.1,4,0.01);
// Smart Keyboard frequency parameter
freq = hslider(&quot;freq&quot;,400,50,2000,0.01);
// Smart Keyboard gate parameter
gate = button(&quot;gate&quot;);

//=================================== Parameters Mapping =================================
//========================================================================================

stringFreq = freq;

//============================================ DSP =======================================
//========================================================================================

process = sy.combString(freq,res,gate);</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust128/exfaust128.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="midionly">midiOnly</h2>
<div class="faust-run"><a href="img/src/exfaust129/exfaust129-svg/process.svg" target="_blank"><img src="img/src/exfaust129/exfaust129-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### midiOnly.dsp ######################################
// Faust instrument specifically designed for `faust2smartkeyb` implementing a MIDI
// controllable app where the mobile device&#39;s touch screen is used to control
// specific parameters of the synth continuously using two separate X/Y control surfaces.
//
// ## `SmartKeyboard` Use Strategy
//
// The `SmartKeyboard` configuration for this instrument consists in a single keyboard
// with two keys. Each key implements a control surface. `Piano Keyboard` mode is
// disabled so that key names are not displayed and that keys don&#39;t change color when
// touched. Finally, `Send Freq` is set to 0 so that new voices are not allocated by
// the touch screen and that the `freq` and `bend` parameters are not computed.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp midiOnly.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

// Interface with 4 polyphnic keyboards of 13 keys with the same config
declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;2&#39;,
    &#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Key X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Key 0 - Label&#39;:&#39;Mod Index&#39;,
    &#39;Keyboard 0 - Key 1 - Label&#39;:&#39;Mod Freq&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
key = hslider(&quot;key&quot;,0,0,1,1) : int;
kb0k0x = hslider(&quot;kb0k0x[midi:ctrl 1]&quot;,0.5,0,1,0.01) : si.smoo;
kb0k1x = hslider(&quot;kb0k1x[midi:ctrl 1]&quot;,0.5,0,1,0.01) : si.smoo;
s = hslider(&quot;sustain[midi:ctrl 64]&quot;,0,0,1,1);
t = button(&quot;gate&quot;);

// fomating parameters
gate = t+s : min(1);
freq = f*bend;
index = kb0k0x*1000;
modFreqRatio = kb0k1x;

envelope = gain*gate : si.smoo;

process = sy.fm((freq,freq + freq*modFreqRatio),index*envelope)*envelope &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust129/exfaust129.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="multisynth">multiSynth</h2>
<div class="faust-run"><a href="img/src/exfaust130/exfaust130-svg/process.svg" target="_blank"><img src="img/src/exfaust130/exfaust130-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### multiSynth.dsp ######################################
// Faust instrument specifically designed for `faust2smartkeyb` where 4 keyboards
// are used to control 4 independent synths.
//
// ## `SmartKeyboard` Use Strategy
//
// The `SmartKeyboard` configuration is relatively simple for this example and
// only consists in four polyphonic keyboards in parallel. The `keyboard` standard
// parameter is used to activate specific elements of the synthesizer.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp multiSynth.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

// Interface with 4 polyphnic keyboards of 13 keys with the same config
declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;4&#39;,
    &#39;Rounding Mode&#39;:&#39;2&#39;,
    &#39;Inter-Keyboard Slide&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;60&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;60&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;60&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;60&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 2 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 3 - Send Y&#39;:&#39;1&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// standard parameters
f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
s = hslider(&quot;sustain[midi:ctrl 64]&quot;,0,0,1,1); // for sustain pedal
t = button(&quot;gate&quot;);
y = hslider(&quot;y[midi:ctrl 1]&quot;,1,0,1,0.001) : si.smoo;
keyboard = hslider(&quot;keyboard&quot;,0,0,3,1) : int;

// fomating parameters
gate = t+s : min(1);
freq = f*bend;
cutoff = y*4000+50;

// oscillators
oscilators(0) = os.sawtooth(freq);
oscilators(1) = os.triangle(freq);
oscilators(2) = os.square(freq);
oscilators(3) = os.osc(freq);

// oscs are selected in function of the current keyboard
synths = par(i,4,select2(keyboard == i,0,oscilators(i))) :&gt; fi.lowpass(3,cutoff) : *(envelope)
with{
    envelope = gate*gain : si.smoo;
};

process = synths &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust130/exfaust130.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="toy">toy</h2>
<div class="faust-run"><a href="img/src/exfaust131/exfaust131-svg/process.svg" target="_blank"><img src="img/src/exfaust131/exfaust131-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//##################################### toy.dsp #######################################
// Faust sound toy specifically designed for `faust2smartkeyb` where a funny
// synth can be controlled using several fingers on the screen and the built-in
// accelerometer.
//
// ## `SmartKeyboard` Use Strategy
//
// We just want a blank screen where the position of the different fingers on
// the screen can be tracked and retrieved in the Faust object. For that, we
// create one keyboard with one key, that should fill the screen. We ask the
// interface to not compute the `freq` and `bend` parameters to save
// computation by setting `&#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;`. We don&#39;t want the
// color of the key to change when it is touched so we deactivate the
// `Piano Keyboard` mode. Fingers should be numbered to be able to use the
// numbered `x` and `y` parameters (`x0`, `y0`, `x1`, etc.), so `Count Fingers`
// is enabled. Finally, by setting `Max Keyboard Polyphony` to 0, we deactivate
// the voice allocation system and we automatically start a voice when the app
// is launched. This means that fingers are no longer associated to specific voices.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] toy.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017:
// https://ccrma.stanford.edu/~rmichon
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

// X/Y interface: one keyboard with one key
// freq and bend are not computed
// fingers are counted
// voice is launched on startup
declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;1&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send Numbered X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Numbered Y&#39;:&#39;1&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// parameters
x0 = hslider(&quot;x0&quot;,0.5,0,1,0.01) : si.smoo;
y0 = hslider(&quot;y0&quot;,0.5,0,1,0.01) : si.smoo;
y1 = hslider(&quot;y1&quot;,0,0,1,0.01) : si.smoo;
q = hslider(&quot;q[acc: 0 0 -10 0 10]&quot;,30,10,50,0.01) : si.smoo;
del = hslider(&quot;del[acc: 0 0 -10 0 10]&quot;,0.5,0.01,1,0.01) : si.smoo;
fb = hslider(&quot;fb[acc: 1 0 -10 0 10]&quot;,0.5,0,1,0.01) : si.smoo;

// mapping
impFreq = 2 + x0*20;
resFreq = y0*3000+300;

// simple echo effect
echo = +~(de.delay(65536,del*ma.SR)*fb);

// putting it together
process = os.lf_imptrain(impFreq) : fi.resonlp(resFreq,q,1) : echo : ef.cubicnl(y1,0)*0.95 &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust131/exfaust131.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="trumpet">trumpet</h2>
<div class="faust-run"><a href="img/src/exfaust132/exfaust132-svg/process.svg" target="_blank"><img src="img/src/exfaust132/exfaust132-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### trumpet.dsp #####################################
// A simple trumpet app... (for large screens).
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp trumpet.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

import(&quot;stdfaust.lib&quot;);

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;5&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;1&#39;,
    &#39;Mono Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;13&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;77&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;72&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;67&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;62&#39;,
    &#39;Keyboard 4 - Lowest Key&#39;:&#39;57&#39;,
    &#39;Rounding Mode&#39;:&#39;2&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 2 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 3 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 4 - Send Y&#39;:&#39;1&#39;,
}&quot;;

// standard parameters
f = hslider(&quot;freq&quot;,300,50,2000,0.01);
bend = hslider(&quot;bend[midi:pitchwheel]&quot;,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
gain = hslider(&quot;gain&quot;,1,0,1,0.01);
s = hslider(&quot;sustain[midi:ctrl 64]&quot;,0,0,1,1); // for sustain pedal
t = button(&quot;gate&quot;);
y = hslider(&quot;y[midi:ctrl 1]&quot;,1,0,1,0.001) : si.smoo;

// fomating parameters
gate = t+s : min(1);
freq = f*bend;
cutoff = y*4000+50;
envelope = gate*gain : si.smoo;

process = os.sawtooth(freq)*envelope : fi.lowpass(3,cutoff) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust132/exfaust132.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="turenas">turenas</h2>
<div class="faust-run"><a href="img/src/exfaust133/exfaust133-svg/process.svg" target="_blank"><img src="img/src/exfaust133/exfaust133-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//################################### turenas.dsp ########################################
// A simple smart phone percussion based on an additive synthesizer.
//
// ## `SmartKeyboard` Use Strategy
//
// Since the sounds generated by this synth are very short, the strategy here is to take
// advantage of the polyphony capabilities of the iOSKeyboard architecture by creating
// a new voice every time a new key is pressed. Since the `SmartKeyboard` interface has a
// large number of keys here (180), lots of sounds are generated when sliding a
// finger across the keyboard.
//
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] turenas.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

declare name &quot;turenas&quot;;

import(&quot;stdfaust.lib&quot;);

//========================= Smart Keyboard Configuration =================================
// (10 keyboards with 18 keys each configured as a pitch matrix.
//========================================================================================

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;10&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 5 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 6 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 7 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 8 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 9 - Number of Keys&#39;:&#39;18&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;50&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;55&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;60&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;65&#39;,
    &#39;Keyboard 4 - Lowest Key&#39;:&#39;70&#39;,
    &#39;Keyboard 5 - Lowest Key&#39;:&#39;75&#39;,
    &#39;Keyboard 6 - Lowest Key&#39;:&#39;80&#39;,
    &#39;Keyboard 7 - Lowest Key&#39;:&#39;85&#39;,
    &#39;Keyboard 8 - Lowest Key&#39;:&#39;90&#39;,
    &#39;Keyboard 9 - Lowest Key&#39;:&#39;95&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 2 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 3 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 4 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 5 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 6 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 7 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 8 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 9 - Piano Keyboard&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 1 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 2 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 3 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 4 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 5 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 6 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 7 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 8 - Send X&#39;:&#39;0&#39;,
    &#39;Keyboard 9 - Send X&#39;:&#39;0&#39;
}&quot;;

//================================ Instrument Parameters =================================
// Creates the connection between the synth and the mobile device
//========================================================================================

// SmartKeyboard Y parameter
y = hslider(&quot;y&quot;,0,0,1,0.01);
// Smart Keyboard frequency parameter
freq = hslider(&quot;freq&quot;,400,50,2000,0.01);
// SmartKeyboard gate parameter
gate = button(&quot;gate&quot;);
// mode resonance duration is controlled with the x axis of the accelerometer
res = hslider(&quot;res[acc: 0 0 -10 0 10]&quot;,2.5,0.01,5,0.01);

//=================================== Parameters Mapping =================================
//========================================================================================

// number of modes
nModes = 6;
// distance between each mode
maxModeSpread = 5;
modeSpread = y*maxModeSpread;
// computing modes frequency ratio
modeFreqRatios = par(i,nModes,1+(i+1)/nModes*modeSpread);
// computing modes gain
minModeGain = 0.3;
modeGains = par(i,nModes,1-(i+1)/(nModes*minModeGain));
// smoothed mode resonance
modeRes = res : si.smoo;

//============================================ DSP =======================================
//========================================================================================

process = sy.additiveDrum(freq,modeFreqRatios,modeGains,0.8,0.001,modeRes,gate)*0.05;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust133/exfaust133.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="violin2">violin2</h2>
<div class="faust-run"><a href="img/src/exfaust134/exfaust134-svg/process.svg" target="_blank"><img src="img/src/exfaust134/exfaust134-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//############################### violin2.dsp ##################################
// Faust instrument specifically designed for `faust2smartkeyb` where a
// complete violin physical model can be played using the touch sceen
// interface. Bowing is carried out by constantly moving a finger on the
// y axis of a key.
//
// ## `SmartKeyboard` Use Strategy
//
// 4 keyboards are used to control the pitch of the 4 bowed strings. Strings
// are connected to the virtual bow when they are touched.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets.
// However it was specifically designed to be used with `faust2smartkeyb`. For
// best results, we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp violin.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Aug. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//##############################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;4&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Rounding Mode&#39;:&#39;2&#39;,
    &#39;Send Fingers Count&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;12&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;12&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;12&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;12&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;55&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;62&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;69&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;76&#39;,
    &#39;Keyboard 0 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 2 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 3 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 2 - Send Y&#39;:&#39;1&#39;,
    &#39;Keyboard 3 - Send Y&#39;:&#39;1&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// SMARTKEYBOARD PARAMS
kbfreq(0) = hslider(&quot;kb0freq&quot;,220,20,10000,0.01);
kbbend(0) = hslider(&quot;kb0bend&quot;,1,0,10,0.01);
kbfreq(1) = hslider(&quot;kb1freq&quot;,330,20,10000,0.01);
kbbend(1) = hslider(&quot;kb1bend&quot;,1,0,10,0.01);
kbfreq(2) = hslider(&quot;kb2freq&quot;,440,20,10000,0.01);
kbbend(2) = hslider(&quot;kb2bend&quot;,1,0,10,0.01);
kbfreq(3) = hslider(&quot;kb3freq&quot;,550,20,10000,0.01);
kbbend(3) = hslider(&quot;kb3bend&quot;,1,0,10,0.01);
kbfingers(0) = hslider(&quot;kb0fingers&quot;,0,0,10,1) : int;
kbfingers(1) = hslider(&quot;kb1fingers&quot;,0,0,10,1) : int;
kbfingers(2) = hslider(&quot;kb2fingers&quot;,0,0,10,1) : int;
kbfingers(3) = hslider(&quot;kb3fingers&quot;,0,0,10,1) : int;
y = hslider(&quot;y&quot;,0,0,1,1) : si.smoo;

// MODEL PARAMETERS
// strings lengths
sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo;
// string active only if fingers are touching the keyboard
as(i) = kbfingers(i)&gt;0;
// retrieving finger displacement on screen (dirt simple)
bowVel = y-y&#39; : abs : *(3000) : min(1) : si.smoo;
// bow position is constant but could be ontrolled by an external interface
bowPos = 0.7;
bowPress = 0.5;

// ASSEMBLING MODELS
// essentially 4 parallel violin strings
model = par(i,4,pm.violinModel(sl(i),bowPress,bowVel*as(i),bowPos)) :&gt; _;

process = model &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust134/exfaust134.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="violin-1">violin</h2>
<div class="faust-run"><a href="img/src/exfaust135/exfaust135-svg/process.svg" target="_blank"><img src="img/src/exfaust135/exfaust135-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//############################### violin.dsp ###################################
// Faust instrument specifically designed for `faust2smartkeyb` where a
// complete violin physical model can be played using the touch sceen
// interface. While the 4 virtual strings can be bowed using a control
// surface on the screen, it could be easily substituted with an external
// interface.
//
// ## `SmartKeyboard` Use Strategy
//
// 4 keyboards are used to control the pitch of the 4 bowed strings. Strings
// are connected to the virtual bow when they are touched. A pad created from
// a keybaord with a single key can be used to control the bow velocity and
// pressure on the selected strings.
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets.
// However it was specifically designed to be used with `faust2smartkeyb`. For
// best results, we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] -effect reverb.dsp violin.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Aug. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//##############################################################################

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;5&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Rounding Mode&#39;:&#39;2&#39;,
    &#39;Send Fingers Count&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 1 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 2 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 3 - Number of Keys&#39;:&#39;19&#39;,
    &#39;Keyboard 4 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Lowest Key&#39;:&#39;55&#39;,
    &#39;Keyboard 1 - Lowest Key&#39;:&#39;62&#39;,
    &#39;Keyboard 2 - Lowest Key&#39;:&#39;69&#39;,
    &#39;Keyboard 3 - Lowest Key&#39;:&#39;76&#39;,
    &#39;Keyboard 0 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 1 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 2 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 3 - Send Keyboard Freq&#39;:&#39;1&#39;,
    &#39;Keyboard 4 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 4 - Send Key X&#39;:&#39;1&#39;,
    &#39;Keyboard 4 - Send Key Y&#39;:&#39;1&#39;,
    &#39;Keyboard 4 - Key 0 - Label&#39;:&#39;Bow&#39;,
    &#39;Keyboard 4 - Static Mode&#39;:&#39;1&#39;
}&quot;;

import(&quot;stdfaust.lib&quot;);

// SMARTKEYBOARD PARAMS
kbfreq(0) = hslider(&quot;kb0freq&quot;,220,20,10000,0.01);
kbbend(0) = hslider(&quot;kb0bend&quot;,1,0,10,0.01);
kbfreq(1) = hslider(&quot;kb1freq&quot;,330,20,10000,0.01);
kbbend(1) = hslider(&quot;kb1bend&quot;,1,0,10,0.01);
kbfreq(2) = hslider(&quot;kb2freq&quot;,440,20,10000,0.01);
kbbend(2) = hslider(&quot;kb2bend&quot;,1,0,10,0.01);
kbfreq(3) = hslider(&quot;kb3freq&quot;,550,20,10000,0.01);
kbbend(3) = hslider(&quot;kb3bend&quot;,1,0,10,0.01);
kb4k0x = hslider(&quot;kb4k0x&quot;,0,0,1,1) : si.smoo;
kb4k0y = hslider(&quot;kb4k0y&quot;,0,0,1,1) : si.smoo;
kbfingers(0) = hslider(&quot;kb0fingers&quot;,0,0,10,1) : int;
kbfingers(1) = hslider(&quot;kb1fingers&quot;,0,0,10,1) : int;
kbfingers(2) = hslider(&quot;kb2fingers&quot;,0,0,10,1) : int;
kbfingers(3) = hslider(&quot;kb3fingers&quot;,0,0,10,1) : int;

// MODEL PARAMETERS
// strings lengths
sl(i) = kbfreq(i)*kbbend(i) : pm.f2l : si.smoo;
// string active only if fingers are touching the keyboard
as(i) = kbfingers(i)&gt;0;
// bow pressure could also be controlled by an external parameter
bowPress = kb4k0y;
// retrieving finger displacement on screen (dirt simple)
bowVel = kb4k0x-kb4k0x&#39; : abs : *(8000) : min(1) : si.smoo;
// bow position is constant but could be ontrolled by an external interface
bowPos = 0.7;

// ASSEMBLING MODELS
// essentially 4 parallel violin strings
model = par(i,4,pm.violinModel(sl(i),bowPress,bowVel*as(i),bowPos)) :&gt; _;

process = model &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust135/exfaust135.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="vocal">vocal</h2>
<div class="faust-run"><a href="img/src/exfaust136/exfaust136-svg/process.svg" target="_blank"><img src="img/src/exfaust136/exfaust136-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>//######################################## vocal.dsp #####################################
// A funny vocal synth app...
//
// ## Compilation Instructions
//
// This Faust code will compile fine with any of the standard Faust targets. However
// it was specifically designed to be used with `faust2smartkeyb`. For best results,
// we recommend to use the following parameters to compile it:
//
// ```
// faust2smartkeyb [-ios/-android] vocal.dsp
// ```
//
// ## Version/Licence
//
// Version 0.0, Feb. 2017
// Copyright Romain Michon CCRMA (Stanford University)/GRAME 2017
// MIT Licence: https://opensource.org/licenses/MIT
//########################################################################################

import(&quot;stdfaust.lib&quot;);

declare interface &quot;SmartKeyboard{
    &#39;Number of Keyboards&#39;:&#39;1&#39;,
    &#39;Max Keyboard Polyphony&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Number of Keys&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send Freq&#39;:&#39;0&#39;,
    &#39;Keyboard 0 - Static Mode&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Send X&#39;:&#39;1&#39;,
    &#39;Keyboard 0 - Piano Keyboard&#39;:&#39;0&#39;
}&quot;;

// standard parameters
vowel = hslider(&quot;vowel[acc: 0 0 -10 0 10]&quot;,2,0,4,0.01) : si.smoo;
x = hslider(&quot;x&quot;,0.5,0,1,0.01) : si.smoo;
vibrato = hslider(&quot;vibrato[acc: 1 0 -10 0 10]&quot;,0.05,0,0.1,0.01);
gain = hslider(&quot;gain&quot;,0.25,0,1,0.01);

// fomating parameters
freq = x*200 + 50;
voiceFreq = freq*(os.osc(6)*vibrato+1);

process = pm.SFFormantModelBP(1,vowel,0,voiceFreq,gain) &lt;: _,_;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust136/exfaust136.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h1 id="spat">spat</h1>
<h2 id="panpot">panpot</h2>
<div class="faust-run"><a href="img/src/exfaust137/exfaust137-svg/process.svg" target="_blank"><img src="img/src/exfaust137/exfaust137-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;panpot&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//-------------------------------------------------
// Stereo panpot
//-------------------------------------------------

panpot(x)   = sqrt(c)*x, sqrt(1-c)*x
            with {
                c=(nentry(&quot;[1]pan[style:knob]&quot;,0,-90,90,1)-90.0)/-180.0;
            };

process     = panpot;</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust137/exfaust137.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div>
<h2 id="spat-1">spat</h2>
<div class="faust-run"><a href="img/src/exfaust138/exfaust138-svg/process.svg" target="_blank"><img src="img/src/exfaust138/exfaust138-svg/process.svg" class="mx-auto d-block"></a>
<pre><code>declare name        &quot;spat&quot;;
declare version     &quot;1.0&quot;;
declare author      &quot;Grame&quot;;
declare license     &quot;BSD&quot;;
declare copyright   &quot;(c)GRAME 2006&quot;;

//==========================================================
//
//                      GMEM SPAT
//  implementation of L. Pottier Spatializer
//
//==========================================================

import(&quot;stdfaust.lib&quot;);

//------------------------------------------------------
// EXEMPLE : une entree mono spatialisee sur 8 sorties
//------------------------------------------------------

angle           = hslider(&quot;angle&quot;,    0.0, 0, 1, 0.01);
distance        = hslider(&quot;distance&quot;, 0.5, 0, 1, 0.01);

process         = vgroup(&quot;Spatializer 1x8&quot;, sp.spat(8, angle, distance));</code></pre>
<a href="https://faust.grame.fr/tools/editor?code=https://faust.grame.fr/manual/img/src/exfaust138/exfaust138.dsp"><button type="button" class="btn btn-primary">Try it Yourself >></button></a></div></div></div></div></main>
